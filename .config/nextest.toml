# Nextest configuration for ruchy
# Optimized for fast test execution (learned from bashrs/certeza)
# Five Whys: Speed comes from parallelism, fail-fast=false, and proper timeouts

[store]
# Store test binaries separately for faster incremental builds
dir = "target/nextest"

[profile.default]
# Default profile for regular test runs
retries = 0
# CRITICAL: fail-fast = false ensures ALL tests run
fail-fast = false
# Use all CPUs for maximum parallelism
test-threads = "num-cpus"
# Reasonable timeout - 60s is enough for most tests
slow-timeout = { period = "60s", terminate-after = 2 }
status-level = "pass"

[profile.coverage]
# Optimized for coverage runs with instrumentation
retries = 0
fail-fast = false
test-threads = "num-cpus"
# Coverage instrumentation adds overhead
slow-timeout = { period = "90s", terminate-after = 2 }
status-level = "pass"

[[profile.default.overrides]]
# Class property tests require single-threaded execution
# Reason: Interpreter is not thread-safe by design
filter = 'test(class_property)'
threads-required = 1

[[profile.default.overrides]]
# File watcher tests are timing-sensitive
filter = 'test(watcher)'
threads-required = 1
slow-timeout = { period = "90s", terminate-after = 2 }

[[profile.default.overrides]]
# REPL tests may have shared state
filter = 'test(repl)'
threads-required = 1

[[profile.default.overrides]]
# env_set_current_dir modifies process-global state
filter = 'test(env_set_current_dir)'
threads-required = 1

[[profile.default.overrides]]
# Property tests need more time
filter = 'test(/property/)'
slow-timeout = { period = "90s", terminate-after = 2 }

[[profile.coverage.overrides]]
# Property tests need even more time under coverage instrumentation
filter = 'test(/property/)'
slow-timeout = { period = "120s", terminate-after = 2 }

[profile.ci]
# CI profile - balanced speed and thoroughness
retries = 1
fail-fast = false
slow-timeout = { period = "120s", terminate-after = 2 }
