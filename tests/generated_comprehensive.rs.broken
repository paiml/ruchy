
//! Generated regression tests from REPL replay sessions
//! 
//! This file is auto-generated by the replay-to-test conversion pipeline.
//! DO NOT EDIT MANUALLY - regenerate from .replay files instead.
//!
//! Generated tests: 490
//! Coverage areas: 26

use anyhow::Result;
use crate::runtime::Repl;


// Unit Tests (315)
// ============================================================================


#[test]
fn test_05_repl_features_001() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Demo 5: REPL-Specific Features");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_002() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Magic commands, introspection, help system, shell integration");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_003() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Variable introspection");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_004() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let x = [1, 2, 3, 4, 5]");
    
    // Expected: Ok("String(\"[1, 2, 3, 4, 5]\")")
    assert_eq!(result, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_005() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let user = { name: \"Alice\", age: 30 }");
    
    // Expected: Ok("String(\"{\\"name\\": \\"Alice\\", \\"age\\": 30}\")")
    assert_eq!(result, Ok("String(\"{\\"name\\": \\"Alice\\", \\"age\\": 30}\")".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_006() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Use magic commands to inspect variables");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_007() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# ?x");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_008() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# ??user");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_009() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# str(x)");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_010() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# summary(user)");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_011() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Help system");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_012() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# help()");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_013() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# help(\"String\")");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_014() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# help(\"Array\")");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_015() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# dir()");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_016() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Type information");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_017() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# type(x)");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_018() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# type(user)");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_019() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# type(42)");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_020() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# type(\"hello\")");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_021() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# History and session management");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_022() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# :history");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_023() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# :bindings");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_024() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# :env");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_025() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Math operations");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_026() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let numbers = [1, 2, 3, 4, 5]");
    
    // Expected: Ok("String(\"[1, 2, 3, 4, 5]\")")
    assert_eq!(result, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_027() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("numbers.sum()");
    
    // Expected: Ok("String(\"15\")")
    assert_eq!(result, Ok("String(\"15\")".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_028() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("numbers.mean()");
    
    // Expected: Err("Unknown list method: mean")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Unknown list method: mean"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_029() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("numbers.max()");
    
    // Expected: Err("Unknown list method: max")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Unknown list method: max"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_030() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("numbers.min()");
    
    // Expected: Err("Unknown list method: min")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Unknown list method: min"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_031() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# String methods");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_032() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let text = \"Hello World\"");
    
    // Expected: Ok("String(\"\\"Hello World\\"\")")
    assert_eq!(result, Ok("String(\"\\"Hello World\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_033() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("text.length()");
    
    // Expected: Ok("String(\"11\")")
    assert_eq!(result, Ok("String(\"11\")".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_034() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("text.upper()");
    
    // Expected: Ok("String(\"\\"HELLO WORLD\\"\")")
    assert_eq!(result, Ok("String(\"\\"HELLO WORLD\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_035() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("text.lower()");
    
    // Expected: Ok("String(\"\\"hello world\\"\")")
    assert_eq!(result, Ok("String(\"\\"hello world\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_036() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("text.split(\" \")");
    
    // Expected: Ok("String(\"[\\"Hello\\", \\"World\\"]\")")
    assert_eq!(result, Ok("String(\"[\\"Hello\\", \\"World\\"]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_037() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("text.contains(\"World\")");
    
    // Expected: Ok("String(\"true\")")
    assert_eq!(result, Ok("String(\"true\")".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_038() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("text.starts_with(\"Hello\")");
    
    // Expected: Ok("String(\"true\")")
    assert_eq!(result, Ok("String(\"true\")".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_039() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("text.ends_with(\"World\")");
    
    // Expected: Ok("String(\"true\")")
    assert_eq!(result, Ok("String(\"true\")".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_040() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Advanced array operations");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_041() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let data = [1, 4, 2, 8, 3, 6]");
    
    // Expected: Ok("String(\"[1, 4, 2, 8, 3, 6]\")")
    assert_eq!(result, Ok("String(\"[1, 4, 2, 8, 3, 6]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_042() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("data.sort()");
    
    // Expected: Err("Unknown list method: sort")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Unknown list method: sort"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_043() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("data.reverse()");
    
    // Expected: Ok("String(\"[6, 3, 8, 2, 4, 1]\")")
    assert_eq!(result, Ok("String(\"[6, 3, 8, 2, 4, 1]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_044() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("data.unique()");
    
    // Expected: Ok("String(\"[1, 4, 2, 8, 3, 6]\")")
    assert_eq!(result, Ok("String(\"[1, 4, 2, 8, 3, 6]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_045() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("data.slice(1, 4)");
    
    // Expected: Ok("String(\"[4, 2, 8]\")")
    assert_eq!(result, Ok("String(\"[4, 2, 8]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_046() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Functional programming");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_047() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let transform = numbers");
    
    // Expected: Ok("String(\"[1, 2, 3, 4, 5]\")")
    assert_eq!(result, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_048() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("    .filter(x => x > 2)");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_049() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("    .map(x => x * 2)");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_050() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("    .reduce((acc, x) => acc + x, 0)");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_051() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("transform");
    
    // Expected: Ok("String(\"[1, 2, 3, 4, 5]\")")
    assert_eq!(result, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_052() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Memory and performance tracking");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_053() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# %time 2 + 2");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_054() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# %timeit factorial(10)");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_055() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Error demonstration for testing error handling");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_056() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# This will cause errors that should be handled gracefully:");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_057() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# undefined_variable");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_058() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# [1, 2, 3][10]");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_059() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# 10 / 0");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_060() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# File operations (if available)");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_061() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# :load example.ruchy");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_062() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# :save session.ruchy");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_05_repl_features_063() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# DataFrame operations (if polars feature enabled)");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_001() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Demo 6: Edge Cases and Error Conditions");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_002() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Stress test the language with boundary conditions, errors, complex expressions");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_003() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Numeric edge cases");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_004() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let max_int = 9223372036854775807");
    
    // Expected: Ok("String(\"9223372036854775807\")")
    assert_eq!(result, Ok("String(\"9223372036854775807\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_005() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let min_int = -9223372036854775808");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_006() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("max_int");
    
    // Expected: Ok("String(\"9223372036854775807\")")
    assert_eq!(result, Ok("String(\"9223372036854775807\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_007() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("min_int");
    
    // Expected: Err("Undefined variable: min_int")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Undefined variable: min_int"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_008() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Float precision");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_009() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let small = 0.000000000001");
    
    // Expected: Ok("String(\"0.000000000001\")")
    assert_eq!(result, Ok("String(\"0.000000000001\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_010() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let large = 1e12");
    
    // Expected: Err("Undefined variable: e12")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Undefined variable: e12"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_011() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("small");
    
    // Expected: Ok("String(\"0.000000000001\")")
    assert_eq!(result, Ok("String(\"0.000000000001\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_012() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("large");
    
    // Expected: Ok("String(\"1\")")
    assert_eq!(result, Ok("String(\"1\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_013() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("small + large");
    
    // Expected: Err("Type mismatch in binary operation: Float(1e-12) Add Int(1)")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Type mismatch in binary operation: Float(1e-12) Add Int(1)"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_014() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# String edge cases");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_015() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let empty = \"\"");
    
    // Expected: Ok("String(\"\\"\\"\")")
    assert_eq!(result, Ok("String(\"\\"\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_016() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let unicode = \"🚀 Hello 世界! 🌟\"");
    
    // Expected: Ok("String(\"\\"🚀 Hello 世界! 🌟\\"\")")
    assert_eq!(result, Ok("String(\"\\"🚀 Hello 世界! 🌟\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_017() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let multiline = \"Line 1\nLine 2\nLine 3\"");
    
    // Expected: Ok("String(\"\\"Line 1\nLine 2\nLine 3\\"\")")
    assert_eq!(result, Ok("String(\"\\"Line 1\nLine 2\nLine 3\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_018() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("empty");
    
    // Expected: Ok("String(\"\\"\\"\")")
    assert_eq!(result, Ok("String(\"\\"\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_019() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("unicode");
    
    // Expected: Ok("String(\"\\"🚀 Hello 世界! 🌟\\"\")")
    assert_eq!(result, Ok("String(\"\\"🚀 Hello 世界! 🌟\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_020() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("multiline");
    
    // Expected: Ok("String(\"\\"Line 1\nLine 2\nLine 3\\"\")")
    assert_eq!(result, Ok("String(\"\\"Line 1\nLine 2\nLine 3\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_021() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Array edge cases");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_022() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let empty_array = []");
    
    // Expected: Ok("String(\"[]\")")
    assert_eq!(result, Ok("String(\"[]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_023() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let nested = [[1, 2], [3, [4, 5]], []]");
    
    // Expected: Ok("String(\"[[1, 2], [3, [4, 5]], []]\")")
    assert_eq!(result, Ok("String(\"[[1, 2], [3, [4, 5]], []]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_024() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let mixed_types = [1, \"hello\", [2, 3], { x: 4 }]");
    
    // Expected: Ok("String(\"[1, \\"hello\\", [2, 3], {\\"x\\": 4}]\")")
    assert_eq!(result, Ok("String(\"[1, \\"hello\\", [2, 3], {\\"x\\": 4}]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_025() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("empty_array");
    
    // Expected: Ok("String(\"[]\")")
    assert_eq!(result, Ok("String(\"[]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_026() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("nested");
    
    // Expected: Ok("String(\"[[1, 2], [3, [4, 5]], []]\")")
    assert_eq!(result, Ok("String(\"[[1, 2], [3, [4, 5]], []]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_027() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("mixed_types");
    
    // Expected: Ok("String(\"[1, \\"hello\\", [2, 3], {\\"x\\": 4}]\")")
    assert_eq!(result, Ok("String(\"[1, \\"hello\\", [2, 3], {\\"x\\": 4}]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_028() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Deep nesting test");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_029() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let deep = { a: { b: { c: { d: { e: \"deep value\" } } } } }");
    
    // Expected: Ok("String(\"{\\"a\\": {\\"b\\": {\\"c\\": {\\"d\\": {\\"e\\": \\"deep value\\"}}}}}\")")
    assert_eq!(result, Ok("String(\"{\\"a\\": {\\"b\\": {\\"c\\": {\\"d\\": {\\"e\\": \\"deep value\\"}}}}}\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_030() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("deep.a.b.c.d.e");
    
    // Expected: Ok("String(\"\\"deep value\\"\")")
    assert_eq!(result, Ok("String(\"\\"deep value\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_031() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Complex expressions");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_032() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let complex = (1 + 2) * (3 + 4) / (5 - 3) + (6 * 7) % 8");
    
    // Expected: Ok("String(\"12\")")
    assert_eq!(result, Ok("String(\"12\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_033() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("complex");
    
    // Expected: Ok("String(\"12\")")
    assert_eq!(result, Ok("String(\"12\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_034() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Pattern matching edge cases");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_035() -> Result<()> {
    // Pasted/multiline input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_036() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("test_patterns(null)");
    
    // Expected: Err("Unknown function: test_patterns")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Unknown function: test_patterns"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_037() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("test_patterns([])");
    
    // Expected: Err("Unknown function: test_patterns")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Unknown function: test_patterns"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_038() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("test_patterns([150])");
    
    // Expected: Err("Unknown function: test_patterns")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Unknown function: test_patterns"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_039() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("test_patterns([5, 5])");
    
    // Expected: Err("Unknown function: test_patterns")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Unknown function: test_patterns"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_040() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("test_patterns({ x: 20, y: 30 })");
    
    // Expected: Err("Unknown function: test_patterns")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Unknown function: test_patterns"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_041() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("test_patterns(\"random\")");
    
    // Expected: Err("Unknown function: test_patterns")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Unknown function: test_patterns"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_042() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Recursion stress test");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_043() -> Result<()> {
    // Pasted/multiline input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("");
    
    // Expected: Ok("String(\"fn fibonacci(n)\")")
    assert_eq!(result, Ok("String(\"fn fibonacci(n)\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_044() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Test with reasonable values to avoid timeout");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_045() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("fibonacci(5)");
    
    // Expected: Ok("String(\"5\")")
    assert_eq!(result, Ok("String(\"5\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_046() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("fibonacci(10)");
    
    // Expected: Ok("String(\"55\")")
    assert_eq!(result, Ok("String(\"55\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_047() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Lambda complexity");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_048() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let complex_lambda = |x| => |y| => |z| => x * y + z");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_049() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let partial = complex_lambda(2)");
    
    // Expected: Err("Unknown function: complex_lambda")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Unknown function: complex_lambda"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_050() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let more_partial = partial(3)");
    
    // Expected: Err("Unknown function: partial")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Unknown function: partial"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_051() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("more_partial(4)");
    
    // Expected: Err("Unknown function: more_partial")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Unknown function: more_partial"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_052() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Method chaining");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_053() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let data = [5, 1, 9, 3, 7, 2, 8, 4, 6]");
    
    // Expected: Ok("String(\"[5, 1, 9, 3, 7, 2, 8, 4, 6]\")")
    assert_eq!(result, Ok("String(\"[5, 1, 9, 3, 7, 2, 8, 4, 6]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_054() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let result = data");
    
    // Expected: Ok("String(\"[5, 1, 9, 3, 7, 2, 8, 4, 6]\")")
    assert_eq!(result, Ok("String(\"[5, 1, 9, 3, 7, 2, 8, 4, 6]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_055() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("    .filter(x => x > 3)");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_056() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("    .sort()");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_057() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("    .map(x => x * 2)");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_058() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("    .slice(0, 3)");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_059() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("    .reverse()");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_060() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("result");
    
    // Expected: Ok("String(\"[5, 1, 9, 3, 7, 2, 8, 4, 6]\")")
    assert_eq!(result, Ok("String(\"[5, 1, 9, 3, 7, 2, 8, 4, 6]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_061() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Error recovery testing");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_062() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# These should be handled gracefully:");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_063() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Undefined variable access");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_064() -> Result<()> {
    // Pasted/multiline input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("");
    
    // Expected: Ok("String(\"\\"Undefined variable handled\\"\")")
    assert_eq!(result, Ok("String(\"\\"Undefined variable handled\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_065() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Array bounds");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_066() -> Result<()> {
    // Pasted/multiline input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("");
    
    // Expected: Ok("String(\"\\"Array bounds handled\\"\")")
    assert_eq!(result, Ok("String(\"\\"Array bounds handled\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_067() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Type mismatches  ");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_068() -> Result<()> {
    // Pasted/multiline input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_069() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Division by zero");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_070() -> Result<()> {
    // Pasted/multiline input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("");
    
    // Expected: Ok("String(\"\\"Division by zero handled\\"\")")
    assert_eq!(result, Ok("String(\"\\"Division by zero handled\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_071() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Memory stress (reasonable limits)");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_072() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let large_array = (1..1000).map(x => x * x)");
    
    // Expected: Err("Method map not supported on this type")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Method map not supported on this type"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_073() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("large_array.length()");
    
    // Expected: Err("Undefined variable: large_array")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Undefined variable: large_array"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_074() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Unicode and special characters");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_075() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let special = \"Tab:\t Newline:\n Quote:\\" Backslash:\\\"");
    
    // Expected: Ok("String(\"\\"Tab:\t Newline:\n Quote:\\" Backslash:\\\\"\")")
    assert_eq!(result, Ok("String(\"\\"Tab:\t Newline:\n Quote:\\" Backslash:\\\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_076() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("special");
    
    // Expected: Ok("String(\"\\"Tab:\t Newline:\n Quote:\\" Backslash:\\\\"\")")
    assert_eq!(result, Ok("String(\"\\"Tab:\t Newline:\n Quote:\\" Backslash:\\\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_077() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Boolean logic complexity");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_078() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let complex_bool = (true || false) && !(false || (true && false))");
    
    // Expected: Ok("String(\"true\")")
    assert_eq!(result, Ok("String(\"true\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_079() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("complex_bool");
    
    // Expected: Ok("String(\"true\")")
    assert_eq!(result, Ok("String(\"true\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_080() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Null handling");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_081() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let null_ops = null");
    
    // Expected: Ok("String(\"Option::None\")")
    assert_eq!(result, Ok("String(\"Option::None\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_082() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("null_ops?.missing");
    
    // Expected: Ok("String(\"null\")")
    assert_eq!(result, Ok("String(\"null\")".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_083() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("null_ops ?? \"default\"");
    
    // Expected: Ok("String(\"Option::None\")")
    assert_eq!(result, Ok("String(\"Option::None\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_001() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Demo 2: Data Structures and Collections");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_02_data_structures_002() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Arrays, tuples, objects, and destructuring");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_02_data_structures_003() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Arrays");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_02_data_structures_004() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let numbers = [1, 2, 3, 4, 5]");
    
    // Expected: Ok("String(\"[1, 2, 3, 4, 5]\")")
    assert_eq!(result, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_005() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let mixed = [1, \"hello\", true, 3.14]");
    
    // Expected: Ok("String(\"[1, \\"hello\\", true, 3.14]\")")
    assert_eq!(result, Ok("String(\"[1, \\"hello\\", true, 3.14]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_006() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("numbers");
    
    // Expected: Ok("String(\"[1, 2, 3, 4, 5]\")")
    assert_eq!(result, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_007() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("mixed");
    
    // Expected: Ok("String(\"[1, \\"hello\\", true, 3.14]\")")
    assert_eq!(result, Ok("String(\"[1, \\"hello\\", true, 3.14]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_008() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Array indexing and methods");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_02_data_structures_009() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("numbers[0]");
    
    // Expected: Ok("String(\"1\")")
    assert_eq!(result, Ok("String(\"1\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_010() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("numbers[4]");
    
    // Expected: Ok("String(\"5\")")
    assert_eq!(result, Ok("String(\"5\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_011() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("numbers.length()");
    
    // Expected: Ok("String(\"5\")")
    assert_eq!(result, Ok("String(\"5\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_012() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("numbers.push(6)");
    
    // Expected: Ok("String(\"[1, 2, 3, 4, 5, 6]\")")
    assert_eq!(result, Ok("String(\"[1, 2, 3, 4, 5, 6]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_013() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("numbers");
    
    // Expected: Ok("String(\"[1, 2, 3, 4, 5]\")")
    assert_eq!(result, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_014() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Array operations");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_02_data_structures_015() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let doubled = numbers.map(x => x * 2)");
    
    // Expected: Ok("String(\"[2, 4, 6, 8, 10]\")")
    assert_eq!(result, Ok("String(\"[2, 4, 6, 8, 10]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_016() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("doubled");
    
    // Expected: Ok("String(\"[2, 4, 6, 8, 10]\")")
    assert_eq!(result, Ok("String(\"[2, 4, 6, 8, 10]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_017() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let sum = numbers.reduce((acc, x) => acc + x, 0)");
    
    // Expected: Ok("String(\"15\")")
    assert_eq!(result, Ok("String(\"15\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_018() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("sum");
    
    // Expected: Ok("String(\"15\")")
    assert_eq!(result, Ok("String(\"15\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_019() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Tuples");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_02_data_structures_020() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let point = (10, 20)");
    
    // Expected: Ok("String(\"(10, 20)\")")
    assert_eq!(result, Ok("String(\"(10, 20)\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_021() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let person = (\"Alice\", 30, true)");
    
    // Expected: Ok("String(\"(\\"Alice\\", 30, true)\")")
    assert_eq!(result, Ok("String(\"(\\"Alice\\", 30, true)\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_022() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("point");
    
    // Expected: Ok("String(\"(10, 20)\")")
    assert_eq!(result, Ok("String(\"(10, 20)\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_023() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("person");
    
    // Expected: Ok("String(\"(\\"Alice\\", 30, true)\")")
    assert_eq!(result, Ok("String(\"(\\"Alice\\", 30, true)\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_024() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Tuple access");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_02_data_structures_025() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("point.0");
    
    // Expected: Ok("String(\"10\")")
    assert_eq!(result, Ok("String(\"10\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_026() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("point.1");
    
    // Expected: Ok("String(\"20\")")
    assert_eq!(result, Ok("String(\"20\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_027() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("person.0");
    
    // Expected: Ok("String(\"\\"Alice\\"\")")
    assert_eq!(result, Ok("String(\"\\"Alice\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_028() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("person.2");
    
    // Expected: Ok("String(\"true\")")
    assert_eq!(result, Ok("String(\"true\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_029() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Tuple destructuring");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_02_data_structures_030() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let (x, y) = point");
    
    // Expected: Ok("String(\"(10, 20)\")")
    assert_eq!(result, Ok("String(\"(10, 20)\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_031() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("x");
    
    // Expected: Ok("String(\"10\")")
    assert_eq!(result, Ok("String(\"10\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_032() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("y");
    
    // Expected: Ok("String(\"20\")")
    assert_eq!(result, Ok("String(\"20\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_033() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let (name, age, active) = person");
    
    // Expected: Ok("String(\"(\\"Alice\\", 30, true)\")")
    assert_eq!(result, Ok("String(\"(\\"Alice\\", 30, true)\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_034() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("name");
    
    // Expected: Ok("String(\"\\"Alice\\"\")")
    assert_eq!(result, Ok("String(\"\\"Alice\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_035() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("age");
    
    // Expected: Ok("String(\"30\")")
    assert_eq!(result, Ok("String(\"30\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_036() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("active");
    
    // Expected: Ok("String(\"true\")")
    assert_eq!(result, Ok("String(\"true\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_037() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Objects");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_02_data_structures_038() -> Result<()> {
    // Pasted/multiline input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("");
    
    // Expected: Ok("String(\"{\\"name\\": \\"Bob\\", \\"age\\": 25, \\"email\\": \\"bob@example.com\\"}\")")
    assert_eq!(result, Ok("String(\"{\\"name\\": \\"Bob\\", \\"age\\": 25, \\"email\\": \\"bob@example.com\\"}\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_039() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Object access");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_02_data_structures_040() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("user.name");
    
    // Expected: Ok("String(\"\\"Bob\\"\")")
    assert_eq!(result, Ok("String(\"\\"Bob\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_041() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("user[\"age\"]");
    
    // Expected: Ok("String(\"25\")")
    assert_eq!(result, Ok("String(\"25\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_042() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("user.email");
    
    // Expected: Ok("String(\"\\"bob@example.com\\"\")")
    assert_eq!(result, Ok("String(\"\\"bob@example.com\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_043() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Object destructuring shorthand");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_02_data_structures_044() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let obj = { x, y }");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_02_data_structures_045() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("obj");
    
    // Expected: Err("Undefined variable: obj")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Undefined variable: obj"));
    
    Ok(())
}

#[test]
fn test_02_data_structures_046() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Nested destructuring");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_001() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Demo 1: Basic Syntax and Variables");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_002() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# This script demonstrates fundamental language features for REPL recording");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_003() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Basic arithmetic");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_004() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("2 + 2");
    
    // Expected: Ok("String(\"4\")")
    assert_eq!(result, Ok("String(\"4\")".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_005() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("5 * 3 + 1");
    
    // Expected: Ok("String(\"16\")")
    assert_eq!(result, Ok("String(\"16\")".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_006() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("10 / 2");
    
    // Expected: Ok("String(\"5\")")
    assert_eq!(result, Ok("String(\"5\")".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_007() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Variables and assignment");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_008() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let x = 42");
    
    // Expected: Ok("String(\"42\")")
    assert_eq!(result, Ok("String(\"42\")".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_009() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let name = \"Ruchy\"");
    
    // Expected: Ok("String(\"\\"Ruchy\\"\")")
    assert_eq!(result, Ok("String(\"\\"Ruchy\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_010() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let pi = 3.14159");
    
    // Expected: Ok("String(\"3.14159\")")
    assert_eq!(result, Ok("String(\"3.14159\")".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_011() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let is_active = true");
    
    // Expected: Ok("String(\"true\")")
    assert_eq!(result, Ok("String(\"true\")".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_012() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Variable access");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_013() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("x");
    
    // Expected: Ok("String(\"42\")")
    assert_eq!(result, Ok("String(\"42\")".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_014() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("name");
    
    // Expected: Ok("String(\"\\"Ruchy\\"\")")
    assert_eq!(result, Ok("String(\"\\"Ruchy\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_015() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("pi");
    
    // Expected: Ok("String(\"3.14159\")")
    assert_eq!(result, Ok("String(\"3.14159\")".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_016() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("is_active");
    
    // Expected: Ok("String(\"true\")")
    assert_eq!(result, Ok("String(\"true\")".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_017() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# String operations");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_018() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("name + \" is awesome!\"");
    
    // Expected: Ok("String(\"\\"Ruchy is awesome!\\"\")")
    assert_eq!(result, Ok("String(\"\\"Ruchy is awesome!\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_019() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("\"Hello, \" + name + \"!\"");
    
    // Expected: Ok("String(\"\\"Hello, Ruchy!\\"\")")
    assert_eq!(result, Ok("String(\"\\"Hello, Ruchy!\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_020() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Boolean operations");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_021() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("true && false");
    
    // Expected: Ok("String(\"false\")")
    assert_eq!(result, Ok("String(\"false\")".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_022() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("!is_active");
    
    // Expected: Ok("String(\"false\")")
    assert_eq!(result, Ok("String(\"false\")".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_023() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("x > 40");
    
    // Expected: Ok("String(\"true\")")
    assert_eq!(result, Ok("String(\"true\")".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_024() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Character literals");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_025() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("'a'");
    
    // Expected: Ok("String(\"'a'\")")
    assert_eq!(result, Ok("String(\"'a'\")".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_026() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("'z'");
    
    // Expected: Ok("String(\"'z'\")")
    assert_eq!(result, Ok("String(\"'z'\")".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_027() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("'🚀'");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_028() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Unit value (should not print)");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_029() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let unit = ()");
    
    // Expected: Ok("String(\"\")")
    assert_eq!(result, Ok("String(\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_030() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("unit");
    
    // Expected: Ok("String(\"\")")
    assert_eq!(result, Ok("String(\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_001() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Demo 4: Advanced Language Features");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_002() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Optional chaining, error handling, async, advanced patterns");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_003() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Optional chaining");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_004() -> Result<()> {
    // Pasted/multiline input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("");
    
    // Expected: Ok("String(\"{\\"profile\\": {\\"settings\\": {\\"theme\\": \\"dark\\"}}}\")")
    assert_eq!(result, Ok("String(\"{\\"profile\\": {\\"settings\\": {\\"theme\\": \\"dark\\"}}}\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_005() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Safe navigation");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_006() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("user?.profile?.settings?.theme");
    
    // Expected: Ok("String(\"\\"dark\\"\")")
    assert_eq!(result, Ok("String(\"\\"dark\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_007() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("user?.profile?.missing?.field");
    
    // Expected: Ok("String(\"null\")")
    assert_eq!(result, Ok("String(\"null\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_008() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let empty_user = null");
    
    // Expected: Ok("String(\"Option::None\")")
    assert_eq!(result, Ok("String(\"Option::None\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_009() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("empty_user?.profile?.settings?.theme");
    
    // Expected: Ok("String(\"null\")")
    assert_eq!(result, Ok("String(\"null\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_010() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Null coalescing");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_011() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let theme = user?.profile?.settings?.theme ?? \"light\"");
    
    // Expected: Ok("String(\"\\"dark\\"\")")
    assert_eq!(result, Ok("String(\"\\"dark\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_012() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("theme");
    
    // Expected: Ok("String(\"\\"dark\\"\")")
    assert_eq!(result, Ok("String(\"\\"dark\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_013() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let missing = user?.profile?.missing?.field ?? \"default\"");
    
    // Expected: Ok("String(\"\\"default\\"\")")
    assert_eq!(result, Ok("String(\"\\"default\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_014() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("missing");
    
    // Expected: Ok("String(\"\\"default\\"\")")
    assert_eq!(result, Ok("String(\"\\"default\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_015() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Try-catch error handling");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_016() -> Result<()> {
    // Pasted/multiline input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("");
    
    // Expected: Ok("String(\"\\"Division by zero handled\\"\")")
    assert_eq!(result, Ok("String(\"\\"Division by zero handled\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_017() -> Result<()> {
    // Pasted/multiline input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_018() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# String interpolation");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_019() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let name = \"Alice\"");
    
    // Expected: Ok("String(\"\\"Alice\\"\")")
    assert_eq!(result, Ok("String(\"\\"Alice\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_020() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let age = 25");
    
    // Expected: Ok("String(\"25\")")
    assert_eq!(result, Ok("String(\"25\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_021() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("f\"Hello, {name}! You are {age} years old.\"");
    
    // Expected: Ok("String(\"\\"Hello, Alice! You are 25 years old.\\"\")")
    assert_eq!(result, Ok("String(\"\\"Hello, Alice! You are 25 years old.\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_022() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let x = 5");
    
    // Expected: Ok("String(\"5\")")
    assert_eq!(result, Ok("String(\"5\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_023() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let y = 3");
    
    // Expected: Ok("String(\"3\")")
    assert_eq!(result, Ok("String(\"3\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_024() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("f\"The sum of {x} and {y} is {x + y}\"");
    
    // Expected: Ok("String(\"\\"The sum of 5 and 3 is 8\\"\")")
    assert_eq!(result, Ok("String(\"\\"The sum of 5 and 3 is 8\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_025() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Pipeline operator");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_026() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let numbers = [1, 2, 3, 4, 5]");
    
    // Expected: Ok("String(\"[1, 2, 3, 4, 5]\")")
    assert_eq!(result, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_027() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let result = numbers");
    
    // Expected: Ok("String(\"[1, 2, 3, 4, 5]\")")
    assert_eq!(result, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_028() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("    |> filter(x => x % 2 == 0)");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_029() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("    |> map(x => x * 2)");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_030() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("    |> reduce((acc, x) => acc + x, 0)");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_031() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("result");
    
    // Expected: Ok("String(\"[1, 2, 3, 4, 5]\")")
    assert_eq!(result, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_032() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Spread operator in arrays");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_033() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let arr1 = [1, 2, 3]");
    
    // Expected: Ok("String(\"[1, 2, 3]\")")
    assert_eq!(result, Ok("String(\"[1, 2, 3]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_034() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let arr2 = [4, 5, 6]");
    
    // Expected: Ok("String(\"[4, 5, 6]\")")
    assert_eq!(result, Ok("String(\"[4, 5, 6]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_035() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let combined = [...arr1, ...arr2]");
    
    // Expected: Ok("String(\"[1, 2, 3, 4, 5, 6]\")")
    assert_eq!(result, Ok("String(\"[1, 2, 3, 4, 5, 6]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_036() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("combined");
    
    // Expected: Ok("String(\"[1, 2, 3, 4, 5, 6]\")")
    assert_eq!(result, Ok("String(\"[1, 2, 3, 4, 5, 6]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_037() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let with_extra = [0, ...arr1, 4, ...arr2, 7]");
    
    // Expected: Ok("String(\"[0, 1, 2, 3, 4, 4, 5, 6, 7]\")")
    assert_eq!(result, Ok("String(\"[0, 1, 2, 3, 4, 4, 5, 6, 7]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_038() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("with_extra");
    
    // Expected: Ok("String(\"[0, 1, 2, 3, 4, 4, 5, 6, 7]\")")
    assert_eq!(result, Ok("String(\"[0, 1, 2, 3, 4, 4, 5, 6, 7]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_039() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Range expansion");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_040() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let range_array = [...1..6]");
    
    // Expected: Ok("String(\"[1, 2, 3, 4, 5]\")")
    assert_eq!(result, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_041() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("range_array");
    
    // Expected: Ok("String(\"[1, 2, 3, 4, 5]\")")
    assert_eq!(result, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_042() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Object spread (if supported)");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_043() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let base_config = { debug: true, timeout: 1000 }");
    
    // Expected: Ok("String(\"{\\"debug\\": true, \\"timeout\\": 1000}\")")
    assert_eq!(result, Ok("String(\"{\\"debug\\": true, \\"timeout\\": 1000}\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_044() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let extended_config = { ...base_config, version: \"1.0\" }");
    
    // Expected: Ok("String(\"{\\"debug\\": true, \\"timeout\\": 1000, \\"version\\": \\"1.0\\"}\")")
    assert_eq!(result, Ok("String(\"{\\"debug\\": true, \\"timeout\\": 1000, \\"version\\": \\"1.0\\"}\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_045() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("extended_config");
    
    // Expected: Ok("String(\"{\\"debug\\": true, \\"timeout\\": 1000, \\"version\\": \\"1.0\\"}\")")
    assert_eq!(result, Ok("String(\"{\\"debug\\": true, \\"timeout\\": 1000, \\"version\\": \\"1.0\\"}\")".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_046() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Pattern guards");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_047() -> Result<()> {
    // Pasted/multiline input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_048() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("classify_number(-5)");
    
    // Expected: Err("Unknown function: classify_number")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Unknown function: classify_number"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_049() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("classify_number(0)");
    
    // Expected: Err("Unknown function: classify_number")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Unknown function: classify_number"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_050() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("classify_number(7)");
    
    // Expected: Err("Unknown function: classify_number")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Unknown function: classify_number"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_051() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("classify_number(42)");
    
    // Expected: Err("Unknown function: classify_number")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Unknown function: classify_number"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_052() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("classify_number(123)");
    
    // Expected: Err("Unknown function: classify_number")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Unknown function: classify_number"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_053() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Array pattern matching");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_054() -> Result<()> {
    // Pasted/multiline input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_055() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("analyze_array([])");
    
    // Expected: Err("Unknown function: analyze_array")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Unknown function: analyze_array"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_056() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("analyze_array([42])");
    
    // Expected: Err("Unknown function: analyze_array")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Unknown function: analyze_array"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_057() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("analyze_array([1, 2])");
    
    // Expected: Err("Unknown function: analyze_array")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Unknown function: analyze_array"));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_058() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("analyze_array([1, 2, 3, 4, 5])");
    
    // Expected: Err("Unknown function: analyze_array")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Unknown function: analyze_array"));
    
    Ok(())
}

#[test]
fn test_03_functions_control_001() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Demo 3: Functions and Control Flow");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_03_functions_control_002() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Function definitions, lambdas, conditionals, loops");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_03_functions_control_003() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Function definitions");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_03_functions_control_004() -> Result<()> {
    // Pasted/multiline input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("");
    
    // Expected: Ok("String(\"fn greet(name)\")")
    assert_eq!(result, Ok("String(\"fn greet(name)\")".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_005() -> Result<()> {
    // Pasted/multiline input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("");
    
    // Expected: Ok("String(\"fn add(a, b)\")")
    assert_eq!(result, Ok("String(\"fn add(a, b)\")".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_006() -> Result<()> {
    // Pasted/multiline input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("");
    
    // Expected: Ok("String(\"fn factorial(n)\")")
    assert_eq!(result, Ok("String(\"fn factorial(n)\")".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_007() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Function calls");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_03_functions_control_008() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("greet(\"World\")");
    
    // Expected: Ok("String(\"\\"Hello, World!\\"\")")
    assert_eq!(result, Ok("String(\"\\"Hello, World!\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_009() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("add(5, 3)");
    
    // Expected: Ok("String(\"8\")")
    assert_eq!(result, Ok("String(\"8\")".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_010() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("factorial(5)");
    
    // Expected: Ok("String(\"120\")")
    assert_eq!(result, Ok("String(\"120\")".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_011() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Lambdas and higher-order functions");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_03_functions_control_012() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let square = x => x * x");
    
    // Expected: Ok("String(\"|x| <closure>\")")
    assert_eq!(result, Ok("String(\"|x| <closure>\")".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_013() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("square(4)");
    
    // Expected: Ok("String(\"16\")")
    assert_eq!(result, Ok("String(\"16\")".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_014() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let numbers = [1, 2, 3, 4, 5]");
    
    // Expected: Ok("String(\"[1, 2, 3, 4, 5]\")")
    assert_eq!(result, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_015() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let squares = numbers.map(x => x * x)");
    
    // Expected: Ok("String(\"[1, 4, 9, 16, 25]\")")
    assert_eq!(result, Ok("String(\"[1, 4, 9, 16, 25]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_016() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("squares");
    
    // Expected: Ok("String(\"[1, 4, 9, 16, 25]\")")
    assert_eq!(result, Ok("String(\"[1, 4, 9, 16, 25]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_017() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let even_numbers = numbers.filter(x => x % 2 == 0)");
    
    // Expected: Ok("String(\"[2, 4]\")")
    assert_eq!(result, Ok("String(\"[2, 4]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_018() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("even_numbers");
    
    // Expected: Ok("String(\"[2, 4]\")")
    assert_eq!(result, Ok("String(\"[2, 4]\")".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_019() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Conditional expressions");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_03_functions_control_020() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let x = 10");
    
    // Expected: Ok("String(\"10\")")
    assert_eq!(result, Ok("String(\"10\")".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_021() -> Result<()> {
    // Pasted/multiline input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("");
    
    // Expected: Ok("String(\"\\"x is greater than 5\\"\")")
    assert_eq!(result, Ok("String(\"\\"x is greater than 5\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_022() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Pattern matching");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_03_functions_control_023() -> Result<()> {
    // Pasted/multiline input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("");
    
    // Expected: Ok("String(\"\\"other\\"\")")
    assert_eq!(result, Ok("String(\"\\"other\\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_024() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Match with destructuring");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_03_functions_control_025() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let point = (5, 3)");
    
    // Expected: Ok("String(\"(5, 3)\")")
    assert_eq!(result, Ok("String(\"(5, 3)\")".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_026() -> Result<()> {
    // Pasted/multiline input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_03_functions_control_027() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Loops");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_03_functions_control_028() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("let mut i = 0");
    
    // Expected: Ok("String(\"0\")")
    assert_eq!(result, Ok("String(\"0\")".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_029() -> Result<()> {
    // Pasted/multiline input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("");
    
    // Expected: Ok("String(\"\")")
    assert_eq!(result, Ok("String(\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_030() -> Result<()> {
    // Pasted/multiline input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("");
    
    // Expected: Ok("String(\"\")")
    assert_eq!(result, Ok("String(\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_031() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Range iteration");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_03_functions_control_032() -> Result<()> {
    // Pasted/multiline input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("");
    
    // Expected: Ok("String(\"\")")
    assert_eq!(result, Ok("String(\"\")".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_033() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("# Loop with break/continue concepts (via early return)");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_03_functions_control_034() -> Result<()> {
    // Pasted/multiline input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("");
    
    // Expected: Err("Failed to parse input")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Failed to parse input"));
    
    Ok(())
}

#[test]
fn test_03_functions_control_035() -> Result<()> {
    // Interactive REPL input
    let mut repl = Repl::new()?;
    
    let deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    let result = repl.eval("find_first_even([1, 3, 4, 7, 8])");
    
    // Expected: Err("Unknown function: find_first_even")
    assert!(result.is_err() && result.unwrap_err().to_string().contains("Unknown function: find_first_even"));
    
    Ok(())
}

// Integration Tests (6)
// ============================================================================


#[test]
fn test_05_repl_features_session_integration() -> Result<()> {
    // Integration test for complete REPL session
    // Tests state persistence and interaction patterns
    let mut repl = Repl::new()?;
    
    // Session timeout
    let _deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    
    // Execute complete session
    let result_0 = repl.eval("# Demo 5: REPL-Specific Features");
    let result_2 = repl.eval("# Magic commands, introspection, help system, shell integration");
    let result_5 = repl.eval("# Variable introspection");
    let result_7 = repl.eval("let x = [1, 2, 3, 4, 5]");
    let result_9 = repl.eval("let user = { name: \"Alice\", age: 30 }");
    let result_12 = repl.eval("# Use magic commands to inspect variables");
    let result_14 = repl.eval("# ?x");
    let result_16 = repl.eval("# ??user");
    let result_18 = repl.eval("# str(x)");
    let result_20 = repl.eval("# summary(user)");
    let result_23 = repl.eval("# Help system");
    let result_25 = repl.eval("# help()");
    let result_27 = repl.eval("# help(\"String\")");
    let result_29 = repl.eval("# help(\"Array\")");
    let result_31 = repl.eval("# dir()");
    let result_34 = repl.eval("# Type information");
    let result_36 = repl.eval("# type(x)");
    let result_38 = repl.eval("# type(user)");
    let result_40 = repl.eval("# type(42)");
    let result_42 = repl.eval("# type(\"hello\")");
    let result_45 = repl.eval("# History and session management");
    let result_47 = repl.eval("# :history");
    let result_49 = repl.eval("# :bindings");
    let result_51 = repl.eval("# :env");
    let result_54 = repl.eval("# Math operations");
    let result_56 = repl.eval("let numbers = [1, 2, 3, 4, 5]");
    let result_58 = repl.eval("numbers.sum()");
    let result_60 = repl.eval("numbers.mean()");
    let result_62 = repl.eval("numbers.max()");
    let result_64 = repl.eval("numbers.min()");
    let result_67 = repl.eval("# String methods");
    let result_69 = repl.eval("let text = \"Hello World\"");
    let result_71 = repl.eval("text.length()");
    let result_73 = repl.eval("text.upper()");
    let result_75 = repl.eval("text.lower()");
    let result_77 = repl.eval("text.split(\" \")");
    let result_79 = repl.eval("text.contains(\"World\")");
    let result_81 = repl.eval("text.starts_with(\"Hello\")");
    let result_83 = repl.eval("text.ends_with(\"World\")");
    let result_86 = repl.eval("# Advanced array operations");
    let result_88 = repl.eval("let data = [1, 4, 2, 8, 3, 6]");
    let result_90 = repl.eval("data.sort()");
    let result_92 = repl.eval("data.reverse()");
    let result_94 = repl.eval("data.unique()");
    let result_96 = repl.eval("data.slice(1, 4)");
    let result_99 = repl.eval("# Functional programming");
    let result_101 = repl.eval("let transform = numbers");
    let result_103 = repl.eval("    .filter(x => x > 2)");
    let result_105 = repl.eval("    .map(x => x * 2)");
    let result_107 = repl.eval("    .reduce((acc, x) => acc + x, 0)");
    let result_109 = repl.eval("transform");
    let result_112 = repl.eval("# Memory and performance tracking");
    let result_114 = repl.eval("# %time 2 + 2");
    let result_116 = repl.eval("# %timeit factorial(10)");
    let result_119 = repl.eval("# Error demonstration for testing error handling");
    let result_121 = repl.eval("# This will cause errors that should be handled gracefully:");
    let result_123 = repl.eval("# undefined_variable");
    let result_125 = repl.eval("# [1, 2, 3][10]");
    let result_127 = repl.eval("# 10 / 0");
    let result_130 = repl.eval("# File operations (if available)");
    let result_132 = repl.eval("# :load example.ruchy");
    let result_134 = repl.eval("# :save session.ruchy");
    let result_137 = repl.eval("# DataFrame operations (if polars feature enabled)");

    
    // Verify all expected outputs
    assert!(result_0.is_err() && result_0.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_2.is_err() && result_2.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_5.is_err() && result_5.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_7, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    assert_eq!(result_9, Ok("String(\"{\\"name\\": \\"Alice\\", \\"age\\": 30}\")".to_string()));
    assert!(result_12.is_err() && result_12.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_14.is_err() && result_14.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_16.is_err() && result_16.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_18.is_err() && result_18.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_20.is_err() && result_20.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_23.is_err() && result_23.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_25.is_err() && result_25.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_27.is_err() && result_27.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_29.is_err() && result_29.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_31.is_err() && result_31.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_34.is_err() && result_34.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_36.is_err() && result_36.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_38.is_err() && result_38.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_40.is_err() && result_40.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_42.is_err() && result_42.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_45.is_err() && result_45.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_47.is_err() && result_47.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_49.is_err() && result_49.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_51.is_err() && result_51.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_54.is_err() && result_54.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_56, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    assert_eq!(result_58, Ok("String(\"15\")".to_string()));
    assert!(result_60.is_err() && result_60.unwrap_err().to_string().contains("Unknown list method: mean"));
    assert!(result_62.is_err() && result_62.unwrap_err().to_string().contains("Unknown list method: max"));
    assert!(result_64.is_err() && result_64.unwrap_err().to_string().contains("Unknown list method: min"));
    assert!(result_67.is_err() && result_67.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_69, Ok("String(\"\\"Hello World\\"\")".to_string()));
    assert_eq!(result_71, Ok("String(\"11\")".to_string()));
    assert_eq!(result_73, Ok("String(\"\\"HELLO WORLD\\"\")".to_string()));
    assert_eq!(result_75, Ok("String(\"\\"hello world\\"\")".to_string()));
    assert_eq!(result_77, Ok("String(\"[\\"Hello\\", \\"World\\"]\")".to_string()));
    assert_eq!(result_79, Ok("String(\"true\")".to_string()));
    assert_eq!(result_81, Ok("String(\"true\")".to_string()));
    assert_eq!(result_83, Ok("String(\"true\")".to_string()));
    assert!(result_86.is_err() && result_86.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_88, Ok("String(\"[1, 4, 2, 8, 3, 6]\")".to_string()));
    assert!(result_90.is_err() && result_90.unwrap_err().to_string().contains("Unknown list method: sort"));
    assert_eq!(result_92, Ok("String(\"[6, 3, 8, 2, 4, 1]\")".to_string()));
    assert_eq!(result_94, Ok("String(\"[1, 4, 2, 8, 3, 6]\")".to_string()));
    assert_eq!(result_96, Ok("String(\"[4, 2, 8]\")".to_string()));
    assert!(result_99.is_err() && result_99.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_101, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    assert!(result_103.is_err() && result_103.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_105.is_err() && result_105.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_107.is_err() && result_107.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_109, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    assert!(result_112.is_err() && result_112.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_114.is_err() && result_114.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_116.is_err() && result_116.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_119.is_err() && result_119.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_121.is_err() && result_121.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_123.is_err() && result_123.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_125.is_err() && result_125.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_127.is_err() && result_127.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_130.is_err() && result_130.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_132.is_err() && result_132.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_134.is_err() && result_134.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_137.is_err() && result_137.unwrap_err().to_string().contains("Failed to parse input"));

    
    Ok(())
}

#[test]
fn test_06_edge_cases_session_integration() -> Result<()> {
    // Integration test for complete REPL session
    // Tests state persistence and interaction patterns
    let mut repl = Repl::new()?;
    
    // Session timeout
    let _deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    
    // Execute complete session
    let result_0 = repl.eval("# Demo 6: Edge Cases and Error Conditions");
    let result_2 = repl.eval("# Stress test the language with boundary conditions, errors, complex expressions");
    let result_5 = repl.eval("# Numeric edge cases");
    let result_7 = repl.eval("let max_int = 9223372036854775807");
    let result_9 = repl.eval("let min_int = -9223372036854775808");
    let result_11 = repl.eval("max_int");
    let result_13 = repl.eval("min_int");
    let result_16 = repl.eval("# Float precision");
    let result_18 = repl.eval("let small = 0.000000000001");
    let result_20 = repl.eval("let large = 1e12");
    let result_22 = repl.eval("small");
    let result_24 = repl.eval("large");
    let result_26 = repl.eval("small + large");
    let result_29 = repl.eval("# String edge cases");
    let result_31 = repl.eval("let empty = \"\"");
    let result_33 = repl.eval("let unicode = \"🚀 Hello 世界! 🌟\"");
    let result_35 = repl.eval("let multiline = \"Line 1\nLine 2\nLine 3\"");
    let result_37 = repl.eval("empty");
    let result_39 = repl.eval("unicode");
    let result_41 = repl.eval("multiline");
    let result_44 = repl.eval("# Array edge cases");
    let result_46 = repl.eval("let empty_array = []");
    let result_48 = repl.eval("let nested = [[1, 2], [3, [4, 5]], []]");
    let result_50 = repl.eval("let mixed_types = [1, \"hello\", [2, 3], { x: 4 }]");
    let result_52 = repl.eval("empty_array");
    let result_54 = repl.eval("nested");
    let result_56 = repl.eval("mixed_types");
    let result_59 = repl.eval("# Deep nesting test");
    let result_61 = repl.eval("let deep = { a: { b: { c: { d: { e: \"deep value\" } } } } }");
    let result_63 = repl.eval("deep.a.b.c.d.e");
    let result_66 = repl.eval("# Complex expressions");
    let result_68 = repl.eval("let complex = (1 + 2) * (3 + 4) / (5 - 3) + (6 * 7) % 8");
    let result_70 = repl.eval("complex");
    let result_73 = repl.eval("# Pattern matching edge cases");
    let result_85 = repl.eval("");
    let result_87 = repl.eval("test_patterns(null)");
    let result_89 = repl.eval("test_patterns([])");
    let result_91 = repl.eval("test_patterns([150])");
    let result_93 = repl.eval("test_patterns([5, 5])");
    let result_95 = repl.eval("test_patterns({ x: 20, y: 30 })");
    let result_97 = repl.eval("test_patterns(\"random\")");
    let result_100 = repl.eval("# Recursion stress test");
    let result_109 = repl.eval("");
    let result_111 = repl.eval("# Test with reasonable values to avoid timeout");
    let result_113 = repl.eval("fibonacci(5)");
    let result_115 = repl.eval("fibonacci(10)");
    let result_118 = repl.eval("# Lambda complexity");
    let result_120 = repl.eval("let complex_lambda = |x| => |y| => |z| => x * y + z");
    let result_122 = repl.eval("let partial = complex_lambda(2)");
    let result_124 = repl.eval("let more_partial = partial(3)");
    let result_126 = repl.eval("more_partial(4)");
    let result_129 = repl.eval("# Method chaining");
    let result_131 = repl.eval("let data = [5, 1, 9, 3, 7, 2, 8, 4, 6]");
    let result_133 = repl.eval("let result = data");
    let result_135 = repl.eval("    .filter(x => x > 3)");
    let result_137 = repl.eval("    .sort()");
    let result_139 = repl.eval("    .map(x => x * 2)");
    let result_141 = repl.eval("    .slice(0, 3)");
    let result_143 = repl.eval("    .reverse()");
    let result_145 = repl.eval("result");
    let result_148 = repl.eval("# Error recovery testing");
    let result_150 = repl.eval("# These should be handled gracefully:");
    let result_153 = repl.eval("# Undefined variable access");
    let result_160 = repl.eval("");
    let result_162 = repl.eval("# Array bounds");
    let result_170 = repl.eval("");
    let result_172 = repl.eval("# Type mismatches  ");
    let result_180 = repl.eval("");
    let result_182 = repl.eval("# Division by zero");
    let result_189 = repl.eval("");
    let result_191 = repl.eval("# Memory stress (reasonable limits)");
    let result_193 = repl.eval("let large_array = (1..1000).map(x => x * x)");
    let result_195 = repl.eval("large_array.length()");
    let result_198 = repl.eval("# Unicode and special characters");
    let result_200 = repl.eval("let special = \"Tab:\t Newline:\n Quote:\\" Backslash:\\\"");
    let result_202 = repl.eval("special");
    let result_205 = repl.eval("# Boolean logic complexity");
    let result_207 = repl.eval("let complex_bool = (true || false) && !(false || (true && false))");
    let result_209 = repl.eval("complex_bool");
    let result_212 = repl.eval("# Null handling");
    let result_214 = repl.eval("let null_ops = null");
    let result_216 = repl.eval("null_ops?.missing");
    let result_218 = repl.eval("null_ops ?? \"default\"");

    
    // Verify all expected outputs
    assert!(result_0.is_err() && result_0.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_2.is_err() && result_2.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_5.is_err() && result_5.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_7, Ok("String(\"9223372036854775807\")".to_string()));
    assert!(result_9.is_err() && result_9.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_11, Ok("String(\"9223372036854775807\")".to_string()));
    assert!(result_13.is_err() && result_13.unwrap_err().to_string().contains("Undefined variable: min_int"));
    assert!(result_16.is_err() && result_16.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_18, Ok("String(\"0.000000000001\")".to_string()));
    assert!(result_20.is_err() && result_20.unwrap_err().to_string().contains("Undefined variable: e12"));
    assert_eq!(result_22, Ok("String(\"0.000000000001\")".to_string()));
    assert_eq!(result_24, Ok("String(\"1\")".to_string()));
    assert!(result_26.is_err() && result_26.unwrap_err().to_string().contains("Type mismatch in binary operation: Float(1e-12) Add Int(1)"));
    assert!(result_29.is_err() && result_29.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_31, Ok("String(\"\\"\\"\")".to_string()));
    assert_eq!(result_33, Ok("String(\"\\"🚀 Hello 世界! 🌟\\"\")".to_string()));
    assert_eq!(result_35, Ok("String(\"\\"Line 1\nLine 2\nLine 3\\"\")".to_string()));
    assert_eq!(result_37, Ok("String(\"\\"\\"\")".to_string()));
    assert_eq!(result_39, Ok("String(\"\\"🚀 Hello 世界! 🌟\\"\")".to_string()));
    assert_eq!(result_41, Ok("String(\"\\"Line 1\nLine 2\nLine 3\\"\")".to_string()));
    assert!(result_44.is_err() && result_44.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_46, Ok("String(\"[]\")".to_string()));
    assert_eq!(result_48, Ok("String(\"[[1, 2], [3, [4, 5]], []]\")".to_string()));
    assert_eq!(result_50, Ok("String(\"[1, \\"hello\\", [2, 3], {\\"x\\": 4}]\")".to_string()));
    assert_eq!(result_52, Ok("String(\"[]\")".to_string()));
    assert_eq!(result_54, Ok("String(\"[[1, 2], [3, [4, 5]], []]\")".to_string()));
    assert_eq!(result_56, Ok("String(\"[1, \\"hello\\", [2, 3], {\\"x\\": 4}]\")".to_string()));
    assert!(result_59.is_err() && result_59.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_61, Ok("String(\"{\\"a\\": {\\"b\\": {\\"c\\": {\\"d\\": {\\"e\\": \\"deep value\\"}}}}}\")".to_string()));
    assert_eq!(result_63, Ok("String(\"\\"deep value\\"\")".to_string()));
    assert!(result_66.is_err() && result_66.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_68, Ok("String(\"12\")".to_string()));
    assert_eq!(result_70, Ok("String(\"12\")".to_string()));
    assert!(result_73.is_err() && result_73.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_85.is_err() && result_85.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_87.is_err() && result_87.unwrap_err().to_string().contains("Unknown function: test_patterns"));
    assert!(result_89.is_err() && result_89.unwrap_err().to_string().contains("Unknown function: test_patterns"));
    assert!(result_91.is_err() && result_91.unwrap_err().to_string().contains("Unknown function: test_patterns"));
    assert!(result_93.is_err() && result_93.unwrap_err().to_string().contains("Unknown function: test_patterns"));
    assert!(result_95.is_err() && result_95.unwrap_err().to_string().contains("Unknown function: test_patterns"));
    assert!(result_97.is_err() && result_97.unwrap_err().to_string().contains("Unknown function: test_patterns"));
    assert!(result_100.is_err() && result_100.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_109, Ok("String(\"fn fibonacci(n)\")".to_string()));
    assert!(result_111.is_err() && result_111.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_113, Ok("String(\"5\")".to_string()));
    assert_eq!(result_115, Ok("String(\"55\")".to_string()));
    assert!(result_118.is_err() && result_118.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_120.is_err() && result_120.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_122.is_err() && result_122.unwrap_err().to_string().contains("Unknown function: complex_lambda"));
    assert!(result_124.is_err() && result_124.unwrap_err().to_string().contains("Unknown function: partial"));
    assert!(result_126.is_err() && result_126.unwrap_err().to_string().contains("Unknown function: more_partial"));
    assert!(result_129.is_err() && result_129.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_131, Ok("String(\"[5, 1, 9, 3, 7, 2, 8, 4, 6]\")".to_string()));
    assert_eq!(result_133, Ok("String(\"[5, 1, 9, 3, 7, 2, 8, 4, 6]\")".to_string()));
    assert!(result_135.is_err() && result_135.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_137.is_err() && result_137.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_139.is_err() && result_139.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_141.is_err() && result_141.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_143.is_err() && result_143.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_145, Ok("String(\"[5, 1, 9, 3, 7, 2, 8, 4, 6]\")".to_string()));
    assert!(result_148.is_err() && result_148.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_150.is_err() && result_150.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_153.is_err() && result_153.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_160, Ok("String(\"\\"Undefined variable handled\\"\")".to_string()));
    assert!(result_162.is_err() && result_162.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_170, Ok("String(\"\\"Array bounds handled\\"\")".to_string()));
    assert!(result_172.is_err() && result_172.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_180.is_err() && result_180.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_182.is_err() && result_182.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_189, Ok("String(\"\\"Division by zero handled\\"\")".to_string()));
    assert!(result_191.is_err() && result_191.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_193.is_err() && result_193.unwrap_err().to_string().contains("Method map not supported on this type"));
    assert!(result_195.is_err() && result_195.unwrap_err().to_string().contains("Undefined variable: large_array"));
    assert!(result_198.is_err() && result_198.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_200, Ok("String(\"\\"Tab:\t Newline:\n Quote:\\" Backslash:\\\\"\")".to_string()));
    assert_eq!(result_202, Ok("String(\"\\"Tab:\t Newline:\n Quote:\\" Backslash:\\\\"\")".to_string()));
    assert!(result_205.is_err() && result_205.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_207, Ok("String(\"true\")".to_string()));
    assert_eq!(result_209, Ok("String(\"true\")".to_string()));
    assert!(result_212.is_err() && result_212.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_214, Ok("String(\"Option::None\")".to_string()));
    assert_eq!(result_216, Ok("String(\"null\")".to_string()));
    assert_eq!(result_218, Ok("String(\"Option::None\")".to_string()));

    
    Ok(())
}

#[test]
fn test_02_data_structures_session_integration() -> Result<()> {
    // Integration test for complete REPL session
    // Tests state persistence and interaction patterns
    let mut repl = Repl::new()?;
    
    // Session timeout
    let _deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    
    // Execute complete session
    let result_0 = repl.eval("# Demo 2: Data Structures and Collections");
    let result_2 = repl.eval("# Arrays, tuples, objects, and destructuring");
    let result_5 = repl.eval("# Arrays");
    let result_7 = repl.eval("let numbers = [1, 2, 3, 4, 5]");
    let result_9 = repl.eval("let mixed = [1, \"hello\", true, 3.14]");
    let result_11 = repl.eval("numbers");
    let result_13 = repl.eval("mixed");
    let result_16 = repl.eval("# Array indexing and methods");
    let result_18 = repl.eval("numbers[0]");
    let result_20 = repl.eval("numbers[4]");
    let result_22 = repl.eval("numbers.length()");
    let result_24 = repl.eval("numbers.push(6)");
    let result_26 = repl.eval("numbers");
    let result_29 = repl.eval("# Array operations");
    let result_31 = repl.eval("let doubled = numbers.map(x => x * 2)");
    let result_33 = repl.eval("doubled");
    let result_35 = repl.eval("let sum = numbers.reduce((acc, x) => acc + x, 0)");
    let result_37 = repl.eval("sum");
    let result_40 = repl.eval("# Tuples");
    let result_42 = repl.eval("let point = (10, 20)");
    let result_44 = repl.eval("let person = (\"Alice\", 30, true)");
    let result_46 = repl.eval("point");
    let result_48 = repl.eval("person");
    let result_51 = repl.eval("# Tuple access");
    let result_53 = repl.eval("point.0");
    let result_55 = repl.eval("point.1");
    let result_57 = repl.eval("person.0");
    let result_59 = repl.eval("person.2");
    let result_62 = repl.eval("# Tuple destructuring");
    let result_64 = repl.eval("let (x, y) = point");
    let result_66 = repl.eval("x");
    let result_68 = repl.eval("y");
    let result_71 = repl.eval("let (name, age, active) = person");
    let result_73 = repl.eval("name");
    let result_75 = repl.eval("age");
    let result_77 = repl.eval("active");
    let result_80 = repl.eval("# Objects");
    let result_88 = repl.eval("");
    let result_90 = repl.eval("# Object access");
    let result_92 = repl.eval("user.name");
    let result_94 = repl.eval("user[\"age\"]");
    let result_96 = repl.eval("user.email");
    let result_99 = repl.eval("# Object destructuring shorthand");
    let result_101 = repl.eval("let obj = { x, y }");
    let result_103 = repl.eval("obj");
    let result_106 = repl.eval("# Nested destructuring");

    
    // Verify all expected outputs
    assert!(result_0.is_err() && result_0.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_2.is_err() && result_2.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_5.is_err() && result_5.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_7, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    assert_eq!(result_9, Ok("String(\"[1, \\"hello\\", true, 3.14]\")".to_string()));
    assert_eq!(result_11, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    assert_eq!(result_13, Ok("String(\"[1, \\"hello\\", true, 3.14]\")".to_string()));
    assert!(result_16.is_err() && result_16.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_18, Ok("String(\"1\")".to_string()));
    assert_eq!(result_20, Ok("String(\"5\")".to_string()));
    assert_eq!(result_22, Ok("String(\"5\")".to_string()));
    assert_eq!(result_24, Ok("String(\"[1, 2, 3, 4, 5, 6]\")".to_string()));
    assert_eq!(result_26, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    assert!(result_29.is_err() && result_29.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_31, Ok("String(\"[2, 4, 6, 8, 10]\")".to_string()));
    assert_eq!(result_33, Ok("String(\"[2, 4, 6, 8, 10]\")".to_string()));
    assert_eq!(result_35, Ok("String(\"15\")".to_string()));
    assert_eq!(result_37, Ok("String(\"15\")".to_string()));
    assert!(result_40.is_err() && result_40.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_42, Ok("String(\"(10, 20)\")".to_string()));
    assert_eq!(result_44, Ok("String(\"(\\"Alice\\", 30, true)\")".to_string()));
    assert_eq!(result_46, Ok("String(\"(10, 20)\")".to_string()));
    assert_eq!(result_48, Ok("String(\"(\\"Alice\\", 30, true)\")".to_string()));
    assert!(result_51.is_err() && result_51.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_53, Ok("String(\"10\")".to_string()));
    assert_eq!(result_55, Ok("String(\"20\")".to_string()));
    assert_eq!(result_57, Ok("String(\"\\"Alice\\"\")".to_string()));
    assert_eq!(result_59, Ok("String(\"true\")".to_string()));
    assert!(result_62.is_err() && result_62.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_64, Ok("String(\"(10, 20)\")".to_string()));
    assert_eq!(result_66, Ok("String(\"10\")".to_string()));
    assert_eq!(result_68, Ok("String(\"20\")".to_string()));
    assert_eq!(result_71, Ok("String(\"(\\"Alice\\", 30, true)\")".to_string()));
    assert_eq!(result_73, Ok("String(\"\\"Alice\\"\")".to_string()));
    assert_eq!(result_75, Ok("String(\"30\")".to_string()));
    assert_eq!(result_77, Ok("String(\"true\")".to_string()));
    assert!(result_80.is_err() && result_80.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_88, Ok("String(\"{\\"name\\": \\"Bob\\", \\"age\\": 25, \\"email\\": \\"bob@example.com\\"}\")".to_string()));
    assert!(result_90.is_err() && result_90.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_92, Ok("String(\"\\"Bob\\"\")".to_string()));
    assert_eq!(result_94, Ok("String(\"25\")".to_string()));
    assert_eq!(result_96, Ok("String(\"\\"bob@example.com\\"\")".to_string()));
    assert!(result_99.is_err() && result_99.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_101.is_err() && result_101.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_103.is_err() && result_103.unwrap_err().to_string().contains("Undefined variable: obj"));
    assert!(result_106.is_err() && result_106.unwrap_err().to_string().contains("Failed to parse input"));

    
    Ok(())
}

#[test]
fn test_01_basic_syntax_session_integration() -> Result<()> {
    // Integration test for complete REPL session
    // Tests state persistence and interaction patterns
    let mut repl = Repl::new()?;
    
    // Session timeout
    let _deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    
    // Execute complete session
    let result_0 = repl.eval("# Demo 1: Basic Syntax and Variables");
    let result_2 = repl.eval("# This script demonstrates fundamental language features for REPL recording");
    let result_5 = repl.eval("# Basic arithmetic");
    let result_7 = repl.eval("2 + 2");
    let result_9 = repl.eval("5 * 3 + 1");
    let result_11 = repl.eval("10 / 2");
    let result_14 = repl.eval("# Variables and assignment");
    let result_16 = repl.eval("let x = 42");
    let result_18 = repl.eval("let name = \"Ruchy\"");
    let result_20 = repl.eval("let pi = 3.14159");
    let result_22 = repl.eval("let is_active = true");
    let result_25 = repl.eval("# Variable access");
    let result_27 = repl.eval("x");
    let result_29 = repl.eval("name");
    let result_31 = repl.eval("pi");
    let result_33 = repl.eval("is_active");
    let result_36 = repl.eval("# String operations");
    let result_38 = repl.eval("name + \" is awesome!\"");
    let result_40 = repl.eval("\"Hello, \" + name + \"!\"");
    let result_43 = repl.eval("# Boolean operations");
    let result_45 = repl.eval("true && false");
    let result_47 = repl.eval("!is_active");
    let result_49 = repl.eval("x > 40");
    let result_52 = repl.eval("# Character literals");
    let result_54 = repl.eval("'a'");
    let result_56 = repl.eval("'z'");
    let result_58 = repl.eval("'🚀'");
    let result_61 = repl.eval("# Unit value (should not print)");
    let result_63 = repl.eval("let unit = ()");
    let result_65 = repl.eval("unit");

    
    // Verify all expected outputs
    assert!(result_0.is_err() && result_0.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_2.is_err() && result_2.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_5.is_err() && result_5.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_7, Ok("String(\"4\")".to_string()));
    assert_eq!(result_9, Ok("String(\"16\")".to_string()));
    assert_eq!(result_11, Ok("String(\"5\")".to_string()));
    assert!(result_14.is_err() && result_14.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_16, Ok("String(\"42\")".to_string()));
    assert_eq!(result_18, Ok("String(\"\\"Ruchy\\"\")".to_string()));
    assert_eq!(result_20, Ok("String(\"3.14159\")".to_string()));
    assert_eq!(result_22, Ok("String(\"true\")".to_string()));
    assert!(result_25.is_err() && result_25.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_27, Ok("String(\"42\")".to_string()));
    assert_eq!(result_29, Ok("String(\"\\"Ruchy\\"\")".to_string()));
    assert_eq!(result_31, Ok("String(\"3.14159\")".to_string()));
    assert_eq!(result_33, Ok("String(\"true\")".to_string()));
    assert!(result_36.is_err() && result_36.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_38, Ok("String(\"\\"Ruchy is awesome!\\"\")".to_string()));
    assert_eq!(result_40, Ok("String(\"\\"Hello, Ruchy!\\"\")".to_string()));
    assert!(result_43.is_err() && result_43.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_45, Ok("String(\"false\")".to_string()));
    assert_eq!(result_47, Ok("String(\"false\")".to_string()));
    assert_eq!(result_49, Ok("String(\"true\")".to_string()));
    assert!(result_52.is_err() && result_52.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_54, Ok("String(\"'a'\")".to_string()));
    assert_eq!(result_56, Ok("String(\"'z'\")".to_string()));
    assert!(result_58.is_err() && result_58.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_61.is_err() && result_61.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_63, Ok("String(\"\")".to_string()));
    assert_eq!(result_65, Ok("String(\"\")".to_string()));

    
    Ok(())
}

#[test]
fn test_04_advanced_features_session_integration() -> Result<()> {
    // Integration test for complete REPL session
    // Tests state persistence and interaction patterns
    let mut repl = Repl::new()?;
    
    // Session timeout
    let _deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    
    // Execute complete session
    let result_0 = repl.eval("# Demo 4: Advanced Language Features");
    let result_2 = repl.eval("# Optional chaining, error handling, async, advanced patterns");
    let result_5 = repl.eval("# Optional chaining");
    let result_14 = repl.eval("");
    let result_16 = repl.eval("# Safe navigation");
    let result_18 = repl.eval("user?.profile?.settings?.theme");
    let result_20 = repl.eval("user?.profile?.missing?.field");
    let result_23 = repl.eval("let empty_user = null");
    let result_25 = repl.eval("empty_user?.profile?.settings?.theme");
    let result_28 = repl.eval("# Null coalescing");
    let result_30 = repl.eval("let theme = user?.profile?.settings?.theme ?? \"light\"");
    let result_32 = repl.eval("theme");
    let result_35 = repl.eval("let missing = user?.profile?.missing?.field ?? \"default\"");
    let result_37 = repl.eval("missing");
    let result_40 = repl.eval("# Try-catch error handling");
    let result_48 = repl.eval("");
    let result_56 = repl.eval("");
    let result_58 = repl.eval("# String interpolation");
    let result_60 = repl.eval("let name = \"Alice\"");
    let result_62 = repl.eval("let age = 25");
    let result_64 = repl.eval("f\"Hello, {name}! You are {age} years old.\"");
    let result_67 = repl.eval("let x = 5");
    let result_69 = repl.eval("let y = 3");
    let result_71 = repl.eval("f\"The sum of {x} and {y} is {x + y}\"");
    let result_74 = repl.eval("# Pipeline operator");
    let result_76 = repl.eval("let numbers = [1, 2, 3, 4, 5]");
    let result_78 = repl.eval("let result = numbers");
    let result_80 = repl.eval("    |> filter(x => x % 2 == 0)");
    let result_82 = repl.eval("    |> map(x => x * 2)");
    let result_84 = repl.eval("    |> reduce((acc, x) => acc + x, 0)");
    let result_86 = repl.eval("result");
    let result_89 = repl.eval("# Spread operator in arrays");
    let result_91 = repl.eval("let arr1 = [1, 2, 3]");
    let result_93 = repl.eval("let arr2 = [4, 5, 6]");
    let result_95 = repl.eval("let combined = [...arr1, ...arr2]");
    let result_97 = repl.eval("combined");
    let result_100 = repl.eval("let with_extra = [0, ...arr1, 4, ...arr2, 7]");
    let result_102 = repl.eval("with_extra");
    let result_105 = repl.eval("# Range expansion");
    let result_107 = repl.eval("let range_array = [...1..6]");
    let result_109 = repl.eval("range_array");
    let result_112 = repl.eval("# Object spread (if supported)");
    let result_114 = repl.eval("let base_config = { debug: true, timeout: 1000 }");
    let result_116 = repl.eval("let extended_config = { ...base_config, version: \"1.0\" }");
    let result_118 = repl.eval("extended_config");
    let result_121 = repl.eval("# Pattern guards");
    let result_132 = repl.eval("");
    let result_134 = repl.eval("classify_number(-5)");
    let result_136 = repl.eval("classify_number(0)");
    let result_138 = repl.eval("classify_number(7)");
    let result_140 = repl.eval("classify_number(42)");
    let result_142 = repl.eval("classify_number(123)");
    let result_145 = repl.eval("# Array pattern matching");
    let result_155 = repl.eval("");
    let result_157 = repl.eval("analyze_array([])");
    let result_159 = repl.eval("analyze_array([42])");
    let result_161 = repl.eval("analyze_array([1, 2])");
    let result_163 = repl.eval("analyze_array([1, 2, 3, 4, 5])");

    
    // Verify all expected outputs
    assert!(result_0.is_err() && result_0.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_2.is_err() && result_2.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_5.is_err() && result_5.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_14, Ok("String(\"{\\"profile\\": {\\"settings\\": {\\"theme\\": \\"dark\\"}}}\")".to_string()));
    assert!(result_16.is_err() && result_16.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_18, Ok("String(\"\\"dark\\"\")".to_string()));
    assert_eq!(result_20, Ok("String(\"null\")".to_string()));
    assert_eq!(result_23, Ok("String(\"Option::None\")".to_string()));
    assert_eq!(result_25, Ok("String(\"null\")".to_string()));
    assert!(result_28.is_err() && result_28.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_30, Ok("String(\"\\"dark\\"\")".to_string()));
    assert_eq!(result_32, Ok("String(\"\\"dark\\"\")".to_string()));
    assert_eq!(result_35, Ok("String(\"\\"default\\"\")".to_string()));
    assert_eq!(result_37, Ok("String(\"\\"default\\"\")".to_string()));
    assert!(result_40.is_err() && result_40.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_48, Ok("String(\"\\"Division by zero handled\\"\")".to_string()));
    assert!(result_56.is_err() && result_56.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_58.is_err() && result_58.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_60, Ok("String(\"\\"Alice\\"\")".to_string()));
    assert_eq!(result_62, Ok("String(\"25\")".to_string()));
    assert_eq!(result_64, Ok("String(\"\\"Hello, Alice! You are 25 years old.\\"\")".to_string()));
    assert_eq!(result_67, Ok("String(\"5\")".to_string()));
    assert_eq!(result_69, Ok("String(\"3\")".to_string()));
    assert_eq!(result_71, Ok("String(\"\\"The sum of 5 and 3 is 8\\"\")".to_string()));
    assert!(result_74.is_err() && result_74.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_76, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    assert_eq!(result_78, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    assert!(result_80.is_err() && result_80.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_82.is_err() && result_82.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_84.is_err() && result_84.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_86, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    assert!(result_89.is_err() && result_89.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_91, Ok("String(\"[1, 2, 3]\")".to_string()));
    assert_eq!(result_93, Ok("String(\"[4, 5, 6]\")".to_string()));
    assert_eq!(result_95, Ok("String(\"[1, 2, 3, 4, 5, 6]\")".to_string()));
    assert_eq!(result_97, Ok("String(\"[1, 2, 3, 4, 5, 6]\")".to_string()));
    assert_eq!(result_100, Ok("String(\"[0, 1, 2, 3, 4, 4, 5, 6, 7]\")".to_string()));
    assert_eq!(result_102, Ok("String(\"[0, 1, 2, 3, 4, 4, 5, 6, 7]\")".to_string()));
    assert!(result_105.is_err() && result_105.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_107, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    assert_eq!(result_109, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    assert!(result_112.is_err() && result_112.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_114, Ok("String(\"{\\"debug\\": true, \\"timeout\\": 1000}\")".to_string()));
    assert_eq!(result_116, Ok("String(\"{\\"debug\\": true, \\"timeout\\": 1000, \\"version\\": \\"1.0\\"}\")".to_string()));
    assert_eq!(result_118, Ok("String(\"{\\"debug\\": true, \\"timeout\\": 1000, \\"version\\": \\"1.0\\"}\")".to_string()));
    assert!(result_121.is_err() && result_121.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_132.is_err() && result_132.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_134.is_err() && result_134.unwrap_err().to_string().contains("Unknown function: classify_number"));
    assert!(result_136.is_err() && result_136.unwrap_err().to_string().contains("Unknown function: classify_number"));
    assert!(result_138.is_err() && result_138.unwrap_err().to_string().contains("Unknown function: classify_number"));
    assert!(result_140.is_err() && result_140.unwrap_err().to_string().contains("Unknown function: classify_number"));
    assert!(result_142.is_err() && result_142.unwrap_err().to_string().contains("Unknown function: classify_number"));
    assert!(result_145.is_err() && result_145.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_155.is_err() && result_155.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_157.is_err() && result_157.unwrap_err().to_string().contains("Unknown function: analyze_array"));
    assert!(result_159.is_err() && result_159.unwrap_err().to_string().contains("Unknown function: analyze_array"));
    assert!(result_161.is_err() && result_161.unwrap_err().to_string().contains("Unknown function: analyze_array"));
    assert!(result_163.is_err() && result_163.unwrap_err().to_string().contains("Unknown function: analyze_array"));

    
    Ok(())
}

#[test]
fn test_03_functions_control_session_integration() -> Result<()> {
    // Integration test for complete REPL session
    // Tests state persistence and interaction patterns
    let mut repl = Repl::new()?;
    
    // Session timeout
    let _deadline = Some(std::time::Instant::now() + std::time::Duration::from_millis(5000));
    
    // Execute complete session
    let result_0 = repl.eval("# Demo 3: Functions and Control Flow");
    let result_2 = repl.eval("# Function definitions, lambdas, conditionals, loops");
    let result_5 = repl.eval("# Function definitions");
    let result_10 = repl.eval("");
    let result_15 = repl.eval("");
    let result_24 = repl.eval("");
    let result_26 = repl.eval("# Function calls");
    let result_28 = repl.eval("greet(\"World\")");
    let result_30 = repl.eval("add(5, 3)");
    let result_32 = repl.eval("factorial(5)");
    let result_35 = repl.eval("# Lambdas and higher-order functions");
    let result_37 = repl.eval("let square = x => x * x");
    let result_39 = repl.eval("square(4)");
    let result_42 = repl.eval("let numbers = [1, 2, 3, 4, 5]");
    let result_44 = repl.eval("let squares = numbers.map(x => x * x)");
    let result_46 = repl.eval("squares");
    let result_49 = repl.eval("let even_numbers = numbers.filter(x => x % 2 == 0)");
    let result_51 = repl.eval("even_numbers");
    let result_54 = repl.eval("# Conditional expressions");
    let result_56 = repl.eval("let x = 10");
    let result_63 = repl.eval("");
    let result_65 = repl.eval("# Pattern matching");
    let result_74 = repl.eval("");
    let result_76 = repl.eval("# Match with destructuring");
    let result_78 = repl.eval("let point = (5, 3)");
    let result_88 = repl.eval("");
    let result_90 = repl.eval("# Loops");
    let result_92 = repl.eval("let mut i = 0");
    let result_98 = repl.eval("");
    let result_103 = repl.eval("");
    let result_105 = repl.eval("# Range iteration");
    let result_110 = repl.eval("");
    let result_112 = repl.eval("# Loop with break/continue concepts (via early return)");
    let result_122 = repl.eval("");
    let result_124 = repl.eval("find_first_even([1, 3, 4, 7, 8])");

    
    // Verify all expected outputs
    assert!(result_0.is_err() && result_0.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_2.is_err() && result_2.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_5.is_err() && result_5.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_10, Ok("String(\"fn greet(name)\")".to_string()));
    assert_eq!(result_15, Ok("String(\"fn add(a, b)\")".to_string()));
    assert_eq!(result_24, Ok("String(\"fn factorial(n)\")".to_string()));
    assert!(result_26.is_err() && result_26.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_28, Ok("String(\"\\"Hello, World!\\"\")".to_string()));
    assert_eq!(result_30, Ok("String(\"8\")".to_string()));
    assert_eq!(result_32, Ok("String(\"120\")".to_string()));
    assert!(result_35.is_err() && result_35.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_37, Ok("String(\"|x| <closure>\")".to_string()));
    assert_eq!(result_39, Ok("String(\"16\")".to_string()));
    assert_eq!(result_42, Ok("String(\"[1, 2, 3, 4, 5]\")".to_string()));
    assert_eq!(result_44, Ok("String(\"[1, 4, 9, 16, 25]\")".to_string()));
    assert_eq!(result_46, Ok("String(\"[1, 4, 9, 16, 25]\")".to_string()));
    assert_eq!(result_49, Ok("String(\"[2, 4]\")".to_string()));
    assert_eq!(result_51, Ok("String(\"[2, 4]\")".to_string()));
    assert!(result_54.is_err() && result_54.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_56, Ok("String(\"10\")".to_string()));
    assert_eq!(result_63, Ok("String(\"\\"x is greater than 5\\"\")".to_string()));
    assert!(result_65.is_err() && result_65.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_74, Ok("String(\"\\"other\\"\")".to_string()));
    assert!(result_76.is_err() && result_76.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_78, Ok("String(\"(5, 3)\")".to_string()));
    assert!(result_88.is_err() && result_88.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_90.is_err() && result_90.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_92, Ok("String(\"0\")".to_string()));
    assert_eq!(result_98, Ok("String(\"\")".to_string()));
    assert_eq!(result_103, Ok("String(\"\")".to_string()));
    assert!(result_105.is_err() && result_105.unwrap_err().to_string().contains("Failed to parse input"));
    assert_eq!(result_110, Ok("String(\"\")".to_string()));
    assert!(result_112.is_err() && result_112.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_122.is_err() && result_122.unwrap_err().to_string().contains("Failed to parse input"));
    assert!(result_124.is_err() && result_124.unwrap_err().to_string().contains("Unknown function: find_first_even"));

    
    Ok(())
}

// Property Tests (12)
// ============================================================================


#[test]
fn test_05_repl_features_determinism_property() -> Result<()> {
    // Property: Session should produce identical results on replay
    use crate::runtime::replay::*;
    
    let mut repl1 = Repl::new()?;
    let mut repl2 = Repl::new()?;
    
    // Execute same sequence on both REPLs
    let inputs = [
        // Insert representative inputs from session
    ];
    
    for input in inputs {
        let result1 = repl1.eval(input);
        let result2 = repl2.eval(input);
        
        match (result1, result2) {
            (Ok(out1), Ok(out2)) => assert_eq!(out1, out2),
            (Err(_), Err(_)) => {}, // Both failed consistently  
            _ => panic!("Inconsistent REPL behavior: {} vs {}", input, input),
        }
    }
    
    Ok(())
}

#[test] 
fn test_05_repl_features_memory_bounds() -> Result<()> {
    // Property: REPL should respect memory limits
    let mut repl = Repl::new()?;
    
    let initial_memory = repl.get_memory_usage();
    
    // Execute session operations
    // ... (session-specific operations)
    
    let final_memory = repl.get_memory_usage();
    
    // Memory should not exceed reasonable bounds (100MB default)
    assert!(final_memory < 100 * 1024 * 1024, "Memory usage exceeded bounds: {} bytes", final_memory);
    
    Ok(())
}

#[test]
fn test_06_edge_cases_determinism_property() -> Result<()> {
    // Property: Session should produce identical results on replay
    use crate::runtime::replay::*;
    
    let mut repl1 = Repl::new()?;
    let mut repl2 = Repl::new()?;
    
    // Execute same sequence on both REPLs
    let inputs = [
        // Insert representative inputs from session
    ];
    
    for input in inputs {
        let result1 = repl1.eval(input);
        let result2 = repl2.eval(input);
        
        match (result1, result2) {
            (Ok(out1), Ok(out2)) => assert_eq!(out1, out2),
            (Err(_), Err(_)) => {}, // Both failed consistently  
            _ => panic!("Inconsistent REPL behavior: {} vs {}", input, input),
        }
    }
    
    Ok(())
}

#[test] 
fn test_06_edge_cases_memory_bounds() -> Result<()> {
    // Property: REPL should respect memory limits
    let mut repl = Repl::new()?;
    
    let initial_memory = repl.get_memory_usage();
    
    // Execute session operations
    // ... (session-specific operations)
    
    let final_memory = repl.get_memory_usage();
    
    // Memory should not exceed reasonable bounds (100MB default)
    assert!(final_memory < 100 * 1024 * 1024, "Memory usage exceeded bounds: {} bytes", final_memory);
    
    Ok(())
}

#[test]
fn test_02_data_structures_determinism_property() -> Result<()> {
    // Property: Session should produce identical results on replay
    use crate::runtime::replay::*;
    
    let mut repl1 = Repl::new()?;
    let mut repl2 = Repl::new()?;
    
    // Execute same sequence on both REPLs
    let inputs = [
        // Insert representative inputs from session
    ];
    
    for input in inputs {
        let result1 = repl1.eval(input);
        let result2 = repl2.eval(input);
        
        match (result1, result2) {
            (Ok(out1), Ok(out2)) => assert_eq!(out1, out2),
            (Err(_), Err(_)) => {}, // Both failed consistently  
            _ => panic!("Inconsistent REPL behavior: {} vs {}", input, input),
        }
    }
    
    Ok(())
}

#[test] 
fn test_02_data_structures_memory_bounds() -> Result<()> {
    // Property: REPL should respect memory limits
    let mut repl = Repl::new()?;
    
    let initial_memory = repl.get_memory_usage();
    
    // Execute session operations
    // ... (session-specific operations)
    
    let final_memory = repl.get_memory_usage();
    
    // Memory should not exceed reasonable bounds (100MB default)
    assert!(final_memory < 100 * 1024 * 1024, "Memory usage exceeded bounds: {} bytes", final_memory);
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_determinism_property() -> Result<()> {
    // Property: Session should produce identical results on replay
    use crate::runtime::replay::*;
    
    let mut repl1 = Repl::new()?;
    let mut repl2 = Repl::new()?;
    
    // Execute same sequence on both REPLs
    let inputs = [
        // Insert representative inputs from session
    ];
    
    for input in inputs {
        let result1 = repl1.eval(input);
        let result2 = repl2.eval(input);
        
        match (result1, result2) {
            (Ok(out1), Ok(out2)) => assert_eq!(out1, out2),
            (Err(_), Err(_)) => {}, // Both failed consistently  
            _ => panic!("Inconsistent REPL behavior: {} vs {}", input, input),
        }
    }
    
    Ok(())
}

#[test] 
fn test_01_basic_syntax_memory_bounds() -> Result<()> {
    // Property: REPL should respect memory limits
    let mut repl = Repl::new()?;
    
    let initial_memory = repl.get_memory_usage();
    
    // Execute session operations
    // ... (session-specific operations)
    
    let final_memory = repl.get_memory_usage();
    
    // Memory should not exceed reasonable bounds (100MB default)
    assert!(final_memory < 100 * 1024 * 1024, "Memory usage exceeded bounds: {} bytes", final_memory);
    
    Ok(())
}

#[test]
fn test_04_advanced_features_determinism_property() -> Result<()> {
    // Property: Session should produce identical results on replay
    use crate::runtime::replay::*;
    
    let mut repl1 = Repl::new()?;
    let mut repl2 = Repl::new()?;
    
    // Execute same sequence on both REPLs
    let inputs = [
        // Insert representative inputs from session
    ];
    
    for input in inputs {
        let result1 = repl1.eval(input);
        let result2 = repl2.eval(input);
        
        match (result1, result2) {
            (Ok(out1), Ok(out2)) => assert_eq!(out1, out2),
            (Err(_), Err(_)) => {}, // Both failed consistently  
            _ => panic!("Inconsistent REPL behavior: {} vs {}", input, input),
        }
    }
    
    Ok(())
}

#[test] 
fn test_04_advanced_features_memory_bounds() -> Result<()> {
    // Property: REPL should respect memory limits
    let mut repl = Repl::new()?;
    
    let initial_memory = repl.get_memory_usage();
    
    // Execute session operations
    // ... (session-specific operations)
    
    let final_memory = repl.get_memory_usage();
    
    // Memory should not exceed reasonable bounds (100MB default)
    assert!(final_memory < 100 * 1024 * 1024, "Memory usage exceeded bounds: {} bytes", final_memory);
    
    Ok(())
}

#[test]
fn test_03_functions_control_determinism_property() -> Result<()> {
    // Property: Session should produce identical results on replay
    use crate::runtime::replay::*;
    
    let mut repl1 = Repl::new()?;
    let mut repl2 = Repl::new()?;
    
    // Execute same sequence on both REPLs
    let inputs = [
        // Insert representative inputs from session
    ];
    
    for input in inputs {
        let result1 = repl1.eval(input);
        let result2 = repl2.eval(input);
        
        match (result1, result2) {
            (Ok(out1), Ok(out2)) => assert_eq!(out1, out2),
            (Err(_), Err(_)) => {}, // Both failed consistently  
            _ => panic!("Inconsistent REPL behavior: {} vs {}", input, input),
        }
    }
    
    Ok(())
}

#[test] 
fn test_03_functions_control_memory_bounds() -> Result<()> {
    // Property: REPL should respect memory limits
    let mut repl = Repl::new()?;
    
    let initial_memory = repl.get_memory_usage();
    
    // Execute session operations
    // ... (session-specific operations)
    
    let final_memory = repl.get_memory_usage();
    
    // Memory should not exceed reasonable bounds (100MB default)
    assert!(final_memory < 100 * 1024 * 1024, "Memory usage exceeded bounds: {} bytes", final_memory);
    
    Ok(())
}

// ErrorHandling Tests (157)
// ============================================================================


#[test]
fn test_05_repl_features_001_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Demo 5: REPL-Specific Features");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_003_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Magic commands, introspection, help system, shell integration");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_006_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Variable introspection");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_013_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Use magic commands to inspect variables");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_015_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# ?x");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_017_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# ??user");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_019_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# str(x)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_021_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# summary(user)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_024_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Help system");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_026_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# help()");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_028_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# help(\"String\")");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_030_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# help(\"Array\")");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_032_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# dir()");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_035_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Type information");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_037_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# type(x)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_039_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# type(user)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_041_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# type(42)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_043_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# type(\"hello\")");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_046_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# History and session management");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_048_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# :history");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_050_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# :bindings");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_052_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# :env");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_055_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Math operations");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_061_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("numbers.mean()");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unknown list method: mean"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_063_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("numbers.max()");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unknown list method: max"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_065_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("numbers.min()");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unknown list method: min"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_068_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# String methods");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_087_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Advanced array operations");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_091_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("data.sort()");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unknown list method: sort"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_100_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Functional programming");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_104_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("    .filter(x => x > 2)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_106_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("    .map(x => x * 2)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_108_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("    .reduce((acc, x) => acc + x, 0)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_113_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Memory and performance tracking");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_115_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# %time 2 + 2");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_117_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# %timeit factorial(10)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_120_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Error demonstration for testing error handling");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_122_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# This will cause errors that should be handled gracefully:");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_124_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# undefined_variable");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_126_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# [1, 2, 3][10]");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_128_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# 10 / 0");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_131_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# File operations (if available)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_133_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# :load example.ruchy");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_135_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# :save session.ruchy");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_05_repl_features_138_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# DataFrame operations (if polars feature enabled)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_001_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Demo 6: Edge Cases and Error Conditions");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_003_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Stress test the language with boundary conditions, errors, complex expressions");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_006_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Numeric edge cases");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_010_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("let min_int = -9223372036854775808");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_014_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("min_int");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Undefined variable: min_int"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_017_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Float precision");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_021_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("let large = 1e12");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Undefined variable: e12"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_027_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("small + large");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Type mismatch in binary operation: Float(1e-12) Add Int(1)"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_030_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# String edge cases");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_045_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Array edge cases");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_060_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Deep nesting test");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_067_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Complex expressions");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_074_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Pattern matching edge cases");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_086_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_088_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("test_patterns(null)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unknown function: test_patterns"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_090_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("test_patterns([])");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unknown function: test_patterns"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_092_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("test_patterns([150])");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unknown function: test_patterns"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_094_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("test_patterns([5, 5])");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unknown function: test_patterns"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_096_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("test_patterns({ x: 20, y: 30 })");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unknown function: test_patterns"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_098_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("test_patterns(\"random\")");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unknown function: test_patterns"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_101_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Recursion stress test");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_112_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Test with reasonable values to avoid timeout");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_119_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Lambda complexity");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_121_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("let complex_lambda = |x| => |y| => |z| => x * y + z");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_123_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("let partial = complex_lambda(2)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unknown function: complex_lambda"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_125_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("let more_partial = partial(3)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unknown function: partial"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_127_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("more_partial(4)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unknown function: more_partial"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_130_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Method chaining");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_136_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("    .filter(x => x > 3)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_138_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("    .sort()");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_140_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("    .map(x => x * 2)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_142_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("    .slice(0, 3)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_144_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("    .reverse()");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_149_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Error recovery testing");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_151_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# These should be handled gracefully:");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_154_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Undefined variable access");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_163_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Array bounds");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_173_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Type mismatches  ");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_181_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_183_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Division by zero");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_192_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Memory stress (reasonable limits)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_194_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("let large_array = (1..1000).map(x => x * x)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Method map not supported on this type"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_196_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("large_array.length()");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Undefined variable: large_array"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_199_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Unicode and special characters");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_206_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Boolean logic complexity");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_06_edge_cases_213_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Null handling");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_001_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Demo 2: Data Structures and Collections");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_003_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Arrays, tuples, objects, and destructuring");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_006_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Arrays");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_017_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Array indexing and methods");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_030_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Array operations");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_041_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Tuples");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_052_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Tuple access");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_063_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Tuple destructuring");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_081_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Objects");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_091_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Object access");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_100_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Object destructuring shorthand");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_102_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("let obj = { x, y }");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_104_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("obj");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Undefined variable: obj"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_02_data_structures_107_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Nested destructuring");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_001_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Demo 1: Basic Syntax and Variables");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_003_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# This script demonstrates fundamental language features for REPL recording");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_006_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Basic arithmetic");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_015_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Variables and assignment");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_026_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Variable access");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_037_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# String operations");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_044_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Boolean operations");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_053_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Character literals");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_059_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("'🚀'");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_01_basic_syntax_062_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Unit value (should not print)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_001_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Demo 4: Advanced Language Features");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_003_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Optional chaining, error handling, async, advanced patterns");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_006_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Optional chaining");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_017_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Safe navigation");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_029_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Null coalescing");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_041_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Try-catch error handling");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_057_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_059_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# String interpolation");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_075_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Pipeline operator");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_081_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("    |> filter(x => x % 2 == 0)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_083_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("    |> map(x => x * 2)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_085_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("    |> reduce((acc, x) => acc + x, 0)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_090_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Spread operator in arrays");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_106_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Range expansion");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_113_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Object spread (if supported)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_122_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Pattern guards");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_133_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_135_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("classify_number(-5)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unknown function: classify_number"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_137_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("classify_number(0)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unknown function: classify_number"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_139_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("classify_number(7)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unknown function: classify_number"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_141_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("classify_number(42)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unknown function: classify_number"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_143_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("classify_number(123)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unknown function: classify_number"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_146_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Array pattern matching");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_156_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_158_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("analyze_array([])");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unknown function: analyze_array"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_160_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("analyze_array([42])");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unknown function: analyze_array"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_162_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("analyze_array([1, 2])");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unknown function: analyze_array"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_04_advanced_features_164_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("analyze_array([1, 2, 3, 4, 5])");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unknown function: analyze_array"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_001_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Demo 3: Functions and Control Flow");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_003_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Function definitions, lambdas, conditionals, loops");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_006_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Function definitions");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_027_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Function calls");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_036_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Lambdas and higher-order functions");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_055_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Conditional expressions");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_066_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Pattern matching");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_077_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Match with destructuring");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_089_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_091_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Loops");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_106_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Range iteration");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_113_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("# Loop with break/continue concepts (via early return)");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_123_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to parse input"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}

#[test]
fn test_03_functions_control_125_error_handling() -> Result<()> {
    // Error handling test: should gracefully handle invalid input
    let mut repl = Repl::new()?;
    
    let result = repl.eval("find_first_even([1, 3, 4, 7, 8])");
    
    // Should fail gracefully with descriptive error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Unknown function: find_first_even"));
    
    // REPL should remain functional after error
    let recovery = repl.eval("2 + 2");
    assert_eq!(recovery, Ok("4".to_string()));
    
    Ok(())
}
