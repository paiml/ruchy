//! Notebook Command Handler
//!
//! Handles notebook server and validation commands.

use anyhow::Result;
use std::path::Path;

/// Handle notebook command
#[cfg(feature = "notebook")]
/// Validate notebook file can be parsed and executed
/// Complexity: 3 (Toyota Way: <10)
fn validate_notebook_file(path: &Path) -> Result<()> {
    use super::{
        compile_rust_code, parse_source, prepare_compilation, read_file_with_context,
        transpile_for_execution,
    };
    use std::fs;

    println!("ðŸ““ Notebook validation mode for: {}", path.display());

    // Validate the file can be parsed and executed
    let source = read_file_with_context(path)?;
    let ast = parse_source(&source)?;
    let rust_code = transpile_for_execution(&ast, path)?;
    let (temp_source, binary_path) = prepare_compilation(&rust_code, false)?;
    compile_rust_code(temp_source.path(), &binary_path)?;

    // Execute the file to validate it runs
    let result = std::process::Command::new(&binary_path).output()?;

    // Cleanup
    let _ = fs::remove_file(&binary_path);

    if result.status.success() {
        println!("âœ… Notebook validation: PASSED");
        println!("   File can be loaded and executed in notebook environment");
        Ok(())
    } else {
        anyhow::bail!(
            "Notebook validation: FAILED\n{}",
            String::from_utf8_lossy(&result.stderr)
        );
    }
}

/// Open browser for notebook interface
/// Complexity: 2 (Toyota Way: <10)
#[cfg(feature = "notebook")]
fn open_browser_for_notebook(url: &str) -> Result<()> {
    use std::process::Command;

    println!("   Opening browser at {}", url);
    #[cfg(target_os = "macos")]
    Command::new("open").arg(url).spawn()?;
    #[cfg(target_os = "linux")]
    Command::new("xdg-open").arg(url).spawn()?;
    #[cfg(target_os = "windows")]
    Command::new("cmd").args(["/C", "start", url]).spawn()?;
    Ok(())
}

/// Handle notebook command - start server or validate file
/// Complexity: 4 (Toyota Way: <10) [Reduced from 14]
#[cfg(feature = "notebook")]
pub fn handle_notebook_command(
    file: Option<&Path>,
    port: u16,
    open_browser: bool,
    host: &str,
) -> Result<()> {
    // TOOL-VALIDATION-003: Non-interactive file validation mode
    if let Some(path) = file {
        return validate_notebook_file(path);
    }

    // Interactive server mode (original behavior)
    println!("ðŸš€ Starting Ruchy Notebook server...");
    println!("   Host: {}:{}", host, port);

    // Create async runtime for the server
    let runtime = tokio::runtime::Runtime::new()?;

    // Open browser if requested
    if open_browser {
        let url = format!("http://{}:{}", host, port);
        open_browser_for_notebook(&url)?;
    }

    // Start the notebook server
    println!(
        "ðŸ”§ DEBUG: About to call ruchy::notebook::start_server({})",
        port
    );
    let result = runtime.block_on(async { ruchy::notebook::start_server(port).await });
    println!("ðŸ”§ DEBUG: Server returned: {:?}", result);
    result.map_err(|e| anyhow::anyhow!("Notebook server error: {}", e))
}

#[cfg(not(feature = "notebook"))]
pub fn handle_notebook_command(
    _file: Option<&Path>,
    _port: u16,
    _open_browser: bool,
    _host: &str,
) -> Result<()> {
    Err(anyhow::anyhow!(
        "Notebook feature not enabled. Rebuild with --features notebook"
    ))
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_notebook_handler_stub() {
        // Notebook handler tests require the notebook feature
        // This is a placeholder
    }
}
