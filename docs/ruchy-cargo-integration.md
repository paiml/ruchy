# Ruchy Cargo Integration Design

## Executive Summary

Ruchy achieves seamless Cargo integration through build-time transpilation, requiring zero modifications to existing Cargo infrastructure. Users interact with standard Cargo commands while Ruchy transparently handles .ruchy files.

## Implementation Architecture

### 1. Build Script Integration (`build.rs`)

```rust
// In user's Cargo.toml
[build-dependencies]
ruchy = "1.0"

// build.rs - Auto-generated or minimal boilerplate
fn main() {
    ruchy::build::transpile_project().unwrap();
}
```

The `transpile_project()` function:
- Scans `src/` for `.ruchy` files
- Generates corresponding `.rs` files in `target/ruchy-gen/`
- Emits `cargo:rerun-if-changed` directives
- Maintains source maps for error reporting
- **Generates virtual `Cargo.toml` manifest for rust-analyzer integration**

Virtual manifest generation:
```toml
# target/ruchy-gen/Cargo.toml (auto-generated)
[package]
name = "ruchy-gen"
version = "0.0.0"

[lib]
path = "lib.rs"  # Root module with #[path] attributes
```

### 2. Module Resolution Strategy (Idiomatic)

```
project/
├── Cargo.toml
├── src/
│   ├── lib.rs           # Standard entry point
│   ├── algo.ruchy       # Ruchy source
│   └── data/
│       ├── mod.ruchy    # Module definition
│       └── process.ruchy
└── target/
    └── ruchy-gen/       # Generated Rust (gitignored)
        ├── algo.rs
        └── data/
            ├── mod.rs   # Generated module root
            └── process.rs
```

User's `lib.rs` (idiomatic):
```rust
// Standard module inclusion
#[path = "../target/ruchy-gen/algo.rs"]
mod algo;

#[path = "../target/ruchy-gen/data/mod.rs"]
mod data;  // Natural submodule structure

pub use algo::*;
pub use data::process::*;
```

Build script generates proper module hierarchy:
```rust
// target/ruchy-gen/data/mod.rs (auto-generated)
pub mod process;
// Re-exports maintain ergonomics
pub use process::*;
```

 = "1.0", features = ["full"] }
reqwest = { version = "0.11", features = ["json"] }
```

### 4. Crate Publishing Strategy

For pure Ruchy libraries:
```toml
[package]
name = "my-ruchy-lib"
version = "0.1.0"

# Indicates this is a Ruchy project
[package.metadata.ruchy]
version = "1.0"
transpile_mode = "library"

[dependencies]
ruchy-runtime = "1.0"  # Minimal runtime for certain features
```

The published crate includes:
- Original `.ruchy` sources
- Pre-generated `.rs` files for compatibility
- Build script for regeneration

### 5. FFI Safety Layer

```rust
// Raw .ruchy FFI declaration
extern "C" {
    fn compress(input: *const u8, len: usize) -> *mut u8;
    fn compressed_size(original_len: usize) -> usize;
}

fun compress_data(data: &[u8]) -> Vec<u8> {
    unsafe {
        let result = compress(data.as_ptr(), data.len());
        // Ruchy injects automatic safety
        Vec::from_raw_parts(result, calculated_len, calculated_cap)
    }
}
```

Generated Rust with safety wrappers:
```rust
// Automatic null-check injection
pub fn compress_data(data: &[u8]) -> Result<Vec<u8>, FFIError> {
    unsafe {
        let expected_size = compressed_size(data.len());
        let result = compress(data.as_ptr(), data.len());
        
        // Ruchy-injected safety checks
        if result.is_null() {
            return Err(FFIError::NullPointer);
        }
        
        // Bounds validation based on heuristics
        if expected_size > data.len() * 10 {
            return Err(FFIError::SuspiciousSize);
        }
        
        // Safe reconstruction with drop guard
        let vec = Vec::from_raw_parts(result, expected_size, expected_size);
        
        // Validate UTF-8 if return type suggests string
        // Additional checks based on function signature analysis
        
        Ok(vec)
    }
}
```

Safety wrapper heuristics:
- Null pointer checks on all raw pointer returns
- Size sanity checks based on input/output relationships  
- Drop guards for resource cleanup
- UTF-8 validation for string-like returns
- Alignment verification for typed pointers

### 6. Incremental Compilation Cache

```rust
// Stored in target/ruchy-cache/
struct RuchyCache {
    // Hash of .ruchy file -> generated .rs
    transpilation_cache: HashMap<FileHash, GeneratedCode>,
    
    // Dependency graph for minimal retranspilation
    dependency_graph: DependencyGraph,
    
    // Type inference results for REPL
    type_cache: TypeInferenceCache,
}
```

### 7. IDE Integration via rust-analyzer

```json
// .vscode/settings.json
{
    "rust-analyzer.linkedProjects": [
        "Cargo.toml",
        "target/ruchy-gen/Cargo.toml"  // Virtual manifest (generated)
    ],
    "rust-analyzer.procMacro.enable": true,
    "ruchy.enableSourceMaps": true
}
```

Virtual manifest structure:
```rust
// Generated by transpile_project() in build.rs
impl VirtualManifestGenerator {
    fn generate(&self, output_dir: &Path) -> Result<()> {
        // Create synthetic Cargo.toml for rust-analyzer
        let manifest = format!(r#"
[package]
name = "{}-ruchy-gen"
version = "0.0.0"
edition = "2021"

[lib]
path = "lib.rs"

[dependencies]
{}
"#, 
            self.project_name,
            self.collect_dependencies()
        );
        
        fs::write(output_dir.join("Cargo.toml"), manifest)?;
        
        // Generate root lib.rs with #[path] directives
        let lib_rs = self.generate_module_tree();
        fs::write(output_dir.join("lib.rs"), lib_rs)?;
        
        Ok(())
    }
}
```

Source maps maintain bidirectional mapping:
- Errors in generated Rust → Original Ruchy location
- Go-to-definition works across languages
- Debugging shows Ruchy source

### 8. CI/CD Integration

```yaml
# GitHub Actions example
- name: Setup Ruchy
  run: cargo install ruchy-cli

- name: Build
  run: cargo build  # Standard - build.rs handles everything

- name: Test
  run: cargo test   # Tests can be in .ruchy files
```

### 9. Performance Guarantees

```rust
#[bench]
fn integration_overhead() {
    // Compilation overhead
    assert!(ruchy_transpile_time < rust_parse_time * 1.5);
    
    // Runtime overhead  
    assert_eq!(ruchy_binary_perf, handwritten_rust_perf);
    
    // Binary size
    assert!(ruchy_binary_size < rust_binary_size * 1.05);
}
```

### 10. Migration Path

For existing Rust projects:
```bash
# Install Ruchy
cargo install ruchy-cli

# Initialize in existing project
ruchy init --mode hybrid

# Gradually migrate modules
ruchy migrate src/complex_module.rs --to src/complex_module.ruchy
```

## Critical Design Decisions (Revised)

### Why Not a Procedural Macro?
- Build scripts provide file system access for source scanning
- Stable Rust compatibility without nightly features
- Superior error reporting with file locations
- Clean separation between transpilation and compilation phases

### Why Generate in `target/`?
- Respects Cargo's build directory conventions
- Automatic gitignore inclusion
- `cargo clean` removes all generated artifacts
- Prevents source tree pollution

### Why Not Modify `Cargo.toml` at Build Time?
- **Fundamental constraint**: `build.rs` executes post-dependency-resolution
- Cargo's dependency graph is immutable during build
- Solution: `ruchy add` command for explicit dependency management
- Maintains deterministic, reproducible builds

### Why Idiomatic Module Structure?
- Reduces cognitive load for Rust developers
- Preserves expected `mod.rs` patterns
- Enables natural submodule organization
- IDE navigation works as expected

## Implementation Timeline

**Phase 1 (Month 1-2):**
- Basic build.rs transpilation
- Module resolution
- Source map generation

**Phase 2 (Month 3-4):**
- Dependency detection
- Incremental compilation
- IDE integration

**Phase 3 (Month 5-6):**
- Crate publishing tools
- Advanced optimizations
- Production hardening

## Success Metrics

- **Zero Cargo modifications**: No patches or forks required
- **<10% compile overhead**: vs pure Rust projects
- **100% crate compatibility**: Any crates.io package works
- **Transparent debugging**: Source maps preserve Ruchy locations

## Example: Using Popular Crates

```rust
// main.ruchy
use axum::{Router, routing::get};
use sqlx::PgPool;

async fun main() {
    let pool = PgPool::connect("postgres://...").await?;
    
    let app = Router::new()
        |> route("/", get(handler))
        |> with_state(pool);
    
    axum::Server::bind("0.0.0.0:3000")
        |> serve(app.into_make_service())
        |> await?;
}

async fun handler(pool: State<PgPool>) -> Json<Vec<User>> {
    sqlx::query_as!(User, "SELECT * FROM users")
        |> fetch_all(&pool)
        |> await
        |> Json
}
```

This compiles to idiomatic Rust with zero runtime overhead, using standard crates.io packages directly.