// 14_macros.ruchy - Macro-like patterns using higher-order functions

fn main() {
    println("=== Macro-like Patterns ===\n")

    // Higher-order functions as macro-like patterns
    println("=== Higher-Order Functions ===")

    // Repeat pattern
    fn repeat(n, func) {
        for i in 0..n {
            func(i)
        }
    }

    repeat(3, i => println(f"Iteration {i}"))

    // Apply to all
    fn apply_all(items, func) {
        items.map(func)
    }

    let numbers = [1, 2, 3, 4, 5]
    let squared = apply_all(numbers, x => x * x)
    println(f"Squared: {squared}")

    // Conditional execution
    println("\n=== Conditional Execution ===")

    fn when(condition, func) {
        if condition {
            func()
        }
    }

    fn say_greater() {
        println("5 is greater than 3")
    }

    when(5 > 3, say_greater)

    fn unless(condition, func) {
        if !condition {
            func()
        }
    }

    fn say_not_greater() {
        println("3 is not greater than 5")
    }

    unless(3 > 5, say_not_greater)

    // Builder pattern using pipelines
    println("\n=== Builder Pattern ===")

    fn make_config() {
        { debug: false, verbose: false, max_retries: 3 }
    }

    fn with_debug(config, value) {
        { debug: value, verbose: config.verbose, max_retries: config.max_retries }
    }

    fn with_verbose(config, value) {
        { debug: config.debug, verbose: value, max_retries: config.max_retries }
    }

    fn with_max_retries(config, value) {
        { debug: config.debug, verbose: config.verbose, max_retries: value }
    }

    let config = make_config()
        |> with_debug(true)
        |> with_verbose(true)
        |> with_max_retries(5)

    println(f"Config: debug={config.debug}, verbose={config.verbose}, retries={config.max_retries}")

    // Pipeline patterns
    println("\n=== Pipeline Patterns ===")

    let data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    let result = data
        |> filter(x => x % 2 == 0)
        |> map(x => x * x)
        |> sum()

    println(f"Sum of squares of evens: {result}")

    // Validation pattern
    println("\n=== Validation Pattern ===")

    fn validate(value, validators) {
        for validator in validators {
            let result = validator(value)
            if !result {
                return false
            }
        }
        true
    }

    let is_positive = x => x > 0
    let is_even = x => x % 2 == 0
    let is_small = x => x < 100

    let validators = [is_positive, is_even, is_small]

    println(f"Is 10 valid? {validate(10, validators)}")
    println(f"Is -2 valid? {validate(-2, validators)}")
    println(f"Is 101 valid? {validate(101, validators)}")

    // Decorator pattern
    println("\n=== Decorator Pattern ===")

    let double = x => x * 2
    println(f"Double of 21: {double(21)}")

    // Currying pattern (simplified)
    println("\n=== Currying Pattern ===")

    fn add(a, b) {
        a + b
    }

    println(f"5 + 3 = {add(5, 3)}")
    println(f"5 + 10 = {add(5, 10)}")

    // Composition pattern (simplified)
    println("\n=== Composition Pattern ===")

    let triple = x => x * 3
    let add_one = x => x + 1

    // Manual composition
    let composed_result = add_one(triple(5))
    println(f"(5 * 3) + 1 = {composed_result}")

    // Partial application (simplified)
    println("\n=== Partial Application ===")

    let results = [1, 2, 3, 4, 5] |> map(x => x * 10)
    println(f"Multiplied by 10: {results}")

    // Tap pattern (for debugging)
    println("\n=== Tap Pattern ===")

    fn tap(value, func) {
        func(value)
        value
    }

    fn debug_print(x) {
        println(f"Debug: {x}")
    }

    let final_result = [1, 2, 3]
        |> map(x => x * 2)
        |> tap(debug_print)
        |> map(x => x + 1)

    println(f"Final result: {final_result}")

    println("\n=== Macro Patterns Complete ===")
}
