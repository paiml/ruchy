// 13_iterators.ruchy - Working with iterators and functional programming

fn main() {
    println("=== Iterators ===\n")

    // Basic iteration
    println("=== Basic Iteration ===")

    let numbers = [1, 2, 3, 4, 5]

    // Simple for loop
    for n in numbers {
        println(f"Number: {n}")
    }

    // Map operation
    println("\n=== Map ===")

    let doubled = numbers.map(x => x * 2)
    println(f"Original: {numbers}")
    println(f"Doubled: {doubled}")

    // Filter operation
    println("\n=== Filter ===")

    let evens = numbers.filter(x => x % 2 == 0)
    println(f"Even numbers: {evens}")

    // Reduce/Fold
    println("\n=== Reduce ===")

    let sum = numbers.reduce(0, (acc, x) => acc + x)
    println(f"Sum: {sum}")

    let product = numbers.reduce(1, (acc, x) => acc * x)
    println(f"Product: {product}")

    // Find operations
    println("\n=== Find Operations ===")

    let first_even = numbers.find(x => x % 2 == 0)
    match first_even {
        Some(n) => println(f"First even: {n}"),
        None => println("No even numbers")
    }

    let has_negative = numbers.any(x => x < 0)
    println(f"Has negative: {has_negative}")

    let all_positive = numbers.all(x => x > 0)
    println(f"All positive: {all_positive}")

    // Take and skip
    println("\n=== Take and Skip ===")

    let first_three = numbers.take(3)
    println(f"First 3: {first_three}")

    let skip_two = numbers.skip(2)
    println(f"After skipping 2: {skip_two}")

    // Zip
    println("\n=== Zip ===")

    let letters = ["a", "b", "c", "d", "e"]
    let pairs = numbers.zip(letters)
    println(f"Zipped pairs: {pairs}")

    // Enumerate
    println("\n=== Enumerate ===")

    let enumerated = numbers.enumerate()
    for pair in enumerated {
        let index = pair.0
        let value = pair.1
        println(f"Index {index}: {value}")
    }

    // Chain using concat
    println("\n=== Chain (using concat) ===")

    let first = [1, 2, 3]
    let second = [4, 5, 6]
    let chained = first.concat(second)
    println(f"Chained: {chained}")

    // Flatten nested arrays
    println("\n=== Flatten ===")

    let nested = [[1, 2], [3, 4], [5, 6]]
    let flattened = nested.flatten()
    println(f"Flattened: {flattened}")

    // Iterator combinators
    println("\n=== Complex Combinations ===")

    let data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    let result = data
        .filter(x => x % 2 == 0)        // Keep even
        .map(x => x * x)                 // Square them
        .filter(x => x < 50)             // Keep under 50
        .reduce(0, (a, b) => a + b)      // Sum them

    println(f"Complex result: {result}")

    // Unique elements
    println("\n=== Unique ===")

    let duplicates = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
    let unique = duplicates.unique()
    println(f"Unique elements: {unique}")

    // Sum, min, max
    println("\n=== Aggregations ===")

    let nums = [5, 2, 8, 1, 9, 3]
    println(f"Sum: {nums.sum()}")
    println(f"Min: {nums.min()}")
    println(f"Max: {nums.max()}")
    println(f"Product: {nums.product()}")

    println("\n=== Iterator Examples Complete ===")
}