// BENCH-002: Matrix Multiplication Benchmark
// Validates Issue #119 fix - global mutable state across function calls
// Pattern: Demonstrates that matrix results can be accumulated globally

// Global result matrix (requires Issue #119 fix to work)
let mut result = []

// Helper function to multiply and store a single cell
// This function MUST be able to mutate the global 'result' array
fun multiply_cell(a, b, i, j, k_max) {
    let mut sum = 0
    let mut k = 0
    while k < k_max {
        sum = sum + (a[i][k] * b[k][j])
        k = k + 1
    }
    result = result + [sum]
}

// Matrix multiplication using global state
fun matrix_multiply(a, b) {
    let rows_a = len(a)
    let cols_b = len(b[0])
    let cols_a = len(a[0])

    let mut i = 0
    while i < rows_a {
        let mut j = 0
        while j < cols_b {
            multiply_cell(a, b, i, j, cols_a)
            j = j + 1
        }
        i = i + 1
    }
}

// Test matrices (2x2 for quick validation)
let a = [[1, 2], [3, 4]]
let b = [[5, 6], [7, 8]]

// Expected result:
// [[1*5 + 2*7, 1*6 + 2*8],   [[19, 22],
//  [3*5 + 4*7, 3*6 + 4*8]] =  [43, 50]]

matrix_multiply(a, b)

println("Matrix multiplication result:")
println(result)  // Should be [19, 22, 43, 50]

// Verify correctness
if len(result) == 4 {
    if result[0] == 19 && result[1] == 22 && result[2] == 43 && result[3] == 50 {
        println("✅ BENCH-002 PASSED - Matrix multiplication correct!")
    } else {
        println("❌ BENCH-002 FAILED - Incorrect values")
    }
} else {
    println("❌ BENCH-002 FAILED - Wrong result size")
}
