ðŸ“Š Running test coverage analysis...
info: cargo-llvm-cov currently setting cfg(coverage) and cfg(coverage_nightly); you can opt-out it by passing --no-cfg-coverage and --no-cfg-coverage-nightly
   Compiling ruchy v3.4.3 (/home/noah/src/ruchy)
warning: unused import: `crate::frontend::ast::StringPart`
   --> src/backend/transpiler/codegen_minimal.rs:598:13
    |
598 |         use crate::frontend::ast::StringPart;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: `#[warn(unused_imports)]` on by default

warning: unused import: `std::collections::HashMap`
   --> src/backend/transpiler/mod.rs:899:9
    |
899 |     use std::collections::HashMap;
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `super::*`
   --> src/frontend/parser/collections.rs:856:9
    |
856 |     use super::*;
    |         ^^^^^^^^

warning: unused import: `super::*`
    --> src/frontend/parser/expressions.rs:2377:9
     |
2377 |     use super::*;
     |         ^^^^^^^^

warning: unused import: `Expr`
    --> src/frontend/parser/expressions.rs:2379:32
     |
2379 |     use crate::frontend::ast::{Expr, ExprKind, Literal};
     |                                ^^^^

warning: unused import: `super::*`
   --> src/frontend/parser/functions.rs:459:9
    |
459 |     use super::*;
    |         ^^^^^^^^

warning: unused import: `crate::frontend::lexer::TokenStream`
    --> src/frontend/parser/utils.rs:1136:13
     |
1136 |         use crate::frontend::lexer::TokenStream;
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::frontend::ast::Span`
    --> src/frontend/parser/utils.rs:1148:13
     |
1148 |         use crate::frontend::ast::Span;
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::path::PathBuf`
   --> src/quality/ruchy_coverage.rs:423:9
    |
423 |     use std::path::PathBuf;
    |         ^^^^^^^^^^^^^^^^^^

warning: unused import: `tempfile::NamedTempFile`
   --> src/runtime/magic.rs:678:9
    |
678 |     use tempfile::NamedTempFile;
    |         ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::io::Write`
   --> src/runtime/magic.rs:679:9
    |
679 |     use std::io::Write;
    |         ^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `generalize` found for struct `middleend::types::TypeScheme` in the current scope
    --> src/middleend/infer.rs:2155:34
     |
2155 |         let scheme = TypeScheme::generalize(&TypeEnv::new(), &MonoType::Var(tv));
     |                                  ^^^^^^^^^^ function or associated item not found in `middleend::types::TypeScheme`
     |
    ::: src/middleend/types.rs:122:1
     |
122  | pub struct TypeScheme {
     | --------------------- function or associated item `generalize` not found for this struct
     |
note: if you're trying to build a new `middleend::types::TypeScheme`, consider using `middleend::types::TypeScheme::mono` which returns `middleend::types::TypeScheme`
    --> src/middleend/types.rs:141:5
     |
141  |     pub fn mono(ty: MonoType) -> Self {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `instantiate` found for struct `infer::InferenceContext` in the current scope
    --> src/middleend/infer.rs:2158:32
     |
8    | pub struct InferenceContext {
     | --------------------------- method `instantiate` not found for this struct
...
2158 |         let instantiated = ctx.instantiate(&scheme);
     |                                ^^^^^^^^^^^ method not found in `infer::InferenceContext`
     |
help: one of the expressions' fields has a method of the same name
     |
2158 |         let instantiated = ctx.env.instantiate(&scheme);
     |                                ++++

error[E0369]: binary operation `==` cannot be applied to type `std::option::Option<&middleend::types::TypeScheme>`
    --> src/middleend/infer.rs:2193:9
     |
2193 |         assert_eq!(env.lookup("x"), Some(&scheme));
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     |         |
     |         std::option::Option<&middleend::types::TypeScheme>
     |         std::option::Option<&middleend::types::TypeScheme>
     |
note: an implementation of `PartialEq` might be missing for `middleend::types::TypeScheme`
    --> src/middleend/types.rs:122:1
     |
122  | pub struct TypeScheme {
     | ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider annotating `middleend::types::TypeScheme` with `#[derive(PartialEq)]`
    -->  src/middleend/types.rs:122:1
     |
122  + #[derive(PartialEq)]
123  | pub struct TypeScheme {
     |

error[E0369]: binary operation `==` cannot be applied to type `std::option::Option<&middleend::types::TypeScheme>`
    --> src/middleend/infer.rs:2194:9
     |
2194 |         assert_eq!(env.lookup("y"), None);
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     |         |
     |         std::option::Option<&middleend::types::TypeScheme>
     |         std::option::Option<&middleend::types::TypeScheme>
     |
note: an implementation of `PartialEq` might be missing for `middleend::types::TypeScheme`
    --> src/middleend/types.rs:122:1
     |
122  | pub struct TypeScheme {
     | ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider annotating `middleend::types::TypeScheme` with `#[derive(PartialEq)]`
    -->  src/middleend/types.rs:122:1
     |
122  + #[derive(PartialEq)]
123  | pub struct TypeScheme {
     |

error[E0599]: no method named `solve_type_constraints` found for struct `infer::InferenceContext` in the current scope
    --> src/middleend/infer.rs:2275:26
     |
8    | pub struct InferenceContext {
     | --------------------------- method `solve_type_constraints` not found for this struct
...
2275 |         let result = ctx.solve_type_constraints();
     |                          ^^^^^^^^^^^^^^^^^^^^^^
     |
help: there is a method `solve_type_constraint` with a similar name, but with different arguments
    --> src/middleend/infer.rs:122:5
     |
122  |     fn solve_type_constraint(&mut self, constraint: TypeConstraint) -> Result<()> {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0560]: struct `sandbox::ProblemTemplate` has no field named `name`
    --> src/notebook/testing/sandbox.rs:1140:13
     |
1140 |             name: "test_template".to_string(),
     |             ^^^^ `sandbox::ProblemTemplate` does not have this field
     |
     = note: available fields are: `problem_type`

error[E0609]: no field `name` on type `sandbox::ProblemTemplate`
    --> src/notebook/testing/sandbox.rs:1144:29
     |
1144 |         assert_eq!(template.name, "test_template");
     |                             ^^^^ unknown field
     |
     = note: available fields are: `problem_type`, `parameter_ranges`

error[E0061]: this function takes 0 arguments but 1 argument was supplied
   --> src/proving/refinement.rs:560:22
    |
560 |         let sorted = RefinementType::sorted_array(BaseType::Int);
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ------------- unexpected argument of type `refinement::BaseType`
    |
note: associated function defined here
   --> src/proving/refinement.rs:105:8
    |
105 | pub fn sorted_array() -> Self {
    |        ^^^^^^^^^^^^
help: remove the extra argument
    |
560 -         let sorted = RefinementType::sorted_array(BaseType::Int);
560 +         let sorted = RefinementType::sorted_array();
    |

error[E0308]: mismatched types
   --> src/proving/refinement.rs:572:50
    |
572 |         let mut refinement = TypeRefinement::new("add", RefinementType::positive_int());
    |                              ------------------- ^^^^^ expected `RefinementType`, found `&str`
    |                              |
    |                              arguments to this function are incorrect
    |
note: associated function defined here
   --> src/proving/refinement.rs:193:8
    |
193 | pub fn new(input: RefinementType, output: RefinementType) -> Self {
    |        ^^^ ---------------------

error[E0609]: no field `name` on type `refinement::TypeRefinement`
   --> src/proving/refinement.rs:573:31
    |
573 |         assert_eq!(refinement.name, "add");
    |                               ^^^^ unknown field
    |
    = note: available fields are: `input`, `output`, `preconditions`, `postconditions`, `invariants`

error[E0599]: no method named `add_arg` found for struct `refinement::TypeRefinement` in the current scope
   --> src/proving/refinement.rs:575:20
    |
155 | pub struct TypeRefinement {
    | ------------------------- method `add_arg` not found for this struct
...
575 |         refinement.add_arg("x", RefinementType::bounded_int(0, 10));
    |                    ^^^^^^^ method not found in `refinement::TypeRefinement`

error[E0609]: no field `args` on type `refinement::TypeRefinement`
   --> src/proving/refinement.rs:576:31
    |
576 |         assert_eq!(refinement.args.len(), 1);
    |                               ^^^^ unknown field
    |
    = note: available fields are: `input`, `output`, `preconditions`, `postconditions`, `invariants`

error[E0609]: no field `args` on type `refinement::TypeRefinement`
   --> src/proving/refinement.rs:577:31
    |
577 |         assert_eq!(refinement.args[0].0, "x");
    |                               ^^^^ unknown field
    |
    = note: available fields are: `input`, `output`, `preconditions`, `postconditions`, `invariants`

error[E0308]: mismatched types
   --> src/proving/refinement.rs:611:46
    |
611 |         let refinement = TypeRefinement::new("increment", RefinementType::positive_int());
    |                          ------------------- ^^^^^^^^^^^ expected `RefinementType`, found `&str`
    |                          |
    |                          arguments to this function are incorrect
    |
note: associated function defined here
   --> src/proving/refinement.rs:193:8
    |
193 | pub fn new(input: RefinementType, output: RefinementType) -> Self {
    |        ^^^ ---------------------

error[E0609]: no field `name` on type `&refinement::TypeRefinement`
   --> src/proving/refinement.rs:617:27
    |
617 |         assert_eq!(stored.name, "increment");
    |                           ^^^^ unknown field
    |
    = note: available fields are: `input`, `output`, `preconditions`, `postconditions`, `invariants`

error[E0061]: this function takes 0 arguments but 1 argument was supplied
   --> src/proving/counterexample.rs:644:19
    |
644 |         let gen = CounterexampleGenerator::new(SmtBackend::Z3);
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -------------- unexpected argument of type `proving::smt::SmtBackend`
    |
note: associated function defined here
   --> src/proving/counterexample.rs:287:12
    |
287 |     pub fn new() -> Self {
    |            ^^^
help: remove the extra argument
    |
644 -         let gen = CounterexampleGenerator::new(SmtBackend::Z3);
644 +         let gen = CounterexampleGenerator::new();
    |

error[E0308]: mismatched types
   --> src/proving/counterexample.rs:647:52
    |
647 |         let cex = gen.build_counterexample("test", HashMap::new());
    |                       --------------------         ^^^^^^^^^^^^^^ expected `Option<HashMap<String, String>>`, found `HashMap<_, _>`
    |                       |
    |                       arguments to this method are incorrect
    |
    = note: expected enum `std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>`
             found struct `std::collections::HashMap<_, _>`
note: method defined here
   --> src/proving/counterexample.rs:342:8
    |
342 |     fn build_counterexample(&self, property: &str, model: Option<HashMap<String, String>>) -> Counterexample {
    |        ^^^^^^^^^^^^^^^^^^^^                        --------------------------------------
help: try wrapping the expression in `Some`
    |
647 |         let cex = gen.build_counterexample("test", Some(HashMap::new()));
    |                                                    +++++              +

error[E0061]: this function takes 0 arguments but 1 argument was supplied
   --> src/proving/counterexample.rs:653:19
    |
653 |         let gen = CounterexampleGenerator::new(SmtBackend::Z3);
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -------------- unexpected argument of type `proving::smt::SmtBackend`
    |
note: associated function defined here
   --> src/proving/counterexample.rs:287:12
    |
287 |     pub fn new() -> Self {
    |            ^^^
help: remove the extra argument
    |
653 -         let gen = CounterexampleGenerator::new(SmtBackend::Z3);
653 +         let gen = CounterexampleGenerator::new();
    |

error[E0308]: mismatched types
   --> src/proving/counterexample.rs:658:57
    |
658 |         let cex = gen.build_counterexample("assertion", model);
    |                       --------------------              ^^^^^ expected `Option<HashMap<String, String>>`, found `HashMap<String, String>`
    |                       |
    |                       arguments to this method are incorrect
    |
    = note: expected enum `std::option::Option<std::collections::HashMap<_, _>>`
             found struct `std::collections::HashMap<_, _>`
note: method defined here
   --> src/proving/counterexample.rs:342:8
    |
342 |     fn build_counterexample(&self, property: &str, model: Option<HashMap<String, String>>) -> Counterexample {
    |        ^^^^^^^^^^^^^^^^^^^^                        --------------------------------------
help: try wrapping the expression in `Some`
    |
658 |         let cex = gen.build_counterexample("assertion", Some(model));
    |                                                         +++++     +

error[E0277]: the trait bound `gates::ViolationType: std::cmp::Eq` is not satisfied
    --> src/quality/gates.rs:819:14
     |
819  |             .collect();
     |              ^^^^^^^ the trait `std::cmp::Eq` is not implemented for `gates::ViolationType`
     |
     = help: the trait `FromIterator<T>` is implemented for `std::collections::HashSet<T, S>`
     = note: required for `&gates::ViolationType` to implement `std::cmp::Eq`
     = note: required for `std::collections::HashSet<&gates::ViolationType>` to implement `FromIterator<&gates::ViolationType>`
note: required by a bound in `collect`
    --> /home/noah/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:2014:19
     |
2014 |     fn collect<B: FromIterator<Self::Item>>(self) -> B
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::collect`
help: consider annotating `gates::ViolationType` with `#[derive(Eq)]`
     |
106  + #[derive(Eq)]
107  | pub enum ViolationType {
     |

error[E0277]: the trait bound `gates::ViolationType: std::hash::Hash` is not satisfied
    --> src/quality/gates.rs:819:14
     |
819  |             .collect();
     |              ^^^^^^^ the trait `std::hash::Hash` is not implemented for `gates::ViolationType`
     |
     = help: the trait `FromIterator<T>` is implemented for `std::collections::HashSet<T, S>`
     = note: required for `&gates::ViolationType` to implement `std::hash::Hash`
     = note: required for `std::collections::HashSet<&gates::ViolationType>` to implement `FromIterator<&gates::ViolationType>`
note: required by a bound in `collect`
    --> /home/noah/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:2014:19
     |
2014 |     fn collect<B: FromIterator<Self::Item>>(self) -> B
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::collect`
help: consider annotating `gates::ViolationType` with `#[derive(Hash)]`
     |
106  + #[derive(Hash)]
107  | pub enum ViolationType {
     |

error[E0599]: the method `contains` exists for struct `std::collections::HashSet<&gates::ViolationType>`, but its trait bounds were not satisfied
   --> src/quality/gates.rs:820:33
    |
106 | pub enum ViolationType {
    | ---------------------- doesn't satisfy `gates::ViolationType: std::cmp::Eq` or `gates::ViolationType: std::hash::Hash`
...
820 |         assert!(violation_types.contains(&ViolationType::OverallScore));
    |                                 ^^^^^^^^ method cannot be called on `std::collections::HashSet<&gates::ViolationType>` due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `gates::ViolationType: std::cmp::Eq`
            which is required by `&gates::ViolationType: std::cmp::Eq`
            `gates::ViolationType: std::hash::Hash`
            which is required by `&gates::ViolationType: std::hash::Hash`
help: consider annotating `gates::ViolationType` with `#[derive(Eq, Hash, PartialEq)]`
    |
106 + #[derive(Eq, Hash, PartialEq)]
107 | pub enum ViolationType {
    |

error[E0599]: the method `contains` exists for struct `std::collections::HashSet<&gates::ViolationType>`, but its trait bounds were not satisfied
   --> src/quality/gates.rs:821:33
    |
106 | pub enum ViolationType {
    | ---------------------- doesn't satisfy `gates::ViolationType: std::cmp::Eq` or `gates::ViolationType: std::hash::Hash`
...
821 |         assert!(violation_types.contains(&ViolationType::Grade));
    |                                 ^^^^^^^^ method cannot be called on `std::collections::HashSet<&gates::ViolationType>` due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `gates::ViolationType: std::cmp::Eq`
            which is required by `&gates::ViolationType: std::cmp::Eq`
            `gates::ViolationType: std::hash::Hash`
            which is required by `&gates::ViolationType: std::hash::Hash`
help: consider annotating `gates::ViolationType` with `#[derive(Eq, Hash, PartialEq)]`
    |
106 + #[derive(Eq, Hash, PartialEq)]
107 | pub enum ViolationType {
    |

error[E0599]: the method `contains` exists for struct `std::collections::HashSet<&gates::ViolationType>`, but its trait bounds were not satisfied
   --> src/quality/gates.rs:822:33
    |
106 | pub enum ViolationType {
    | ---------------------- doesn't satisfy `gates::ViolationType: std::cmp::Eq` or `gates::ViolationType: std::hash::Hash`
...
822 |         assert!(violation_types.contains(&ViolationType::Confidence));
    |                                 ^^^^^^^^ method cannot be called on `std::collections::HashSet<&gates::ViolationType>` due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `gates::ViolationType: std::cmp::Eq`
            which is required by `&gates::ViolationType: std::cmp::Eq`
            `gates::ViolationType: std::hash::Hash`
            which is required by `&gates::ViolationType: std::hash::Hash`
help: consider annotating `gates::ViolationType` with `#[derive(Eq, Hash, PartialEq)]`
    |
106 + #[derive(Eq, Hash, PartialEq)]
107 | pub enum ViolationType {
    |

error[E0559]: variant `ast::ExprKind::Let` has no field named `ty`
   --> src/quality/formatter.rs:247:17
    |
247 |                 ty: Some(Type {
    |                 ^^ `ast::ExprKind::Let` does not have this field
    |
    = note: available fields are: `type_annotation`, `is_mutable`

error[E0559]: variant `ast::ExprKind::Let` has no field named `is_mut`
   --> src/quality/formatter.rs:251:17
    |
251 |                 is_mut: false,
    |                 ^^^^^^ `ast::ExprKind::Let` does not have this field
    |
    = note: available fields are: `type_annotation`, `is_mutable`

error[E0599]: no variant or associated item named `Gt` found for enum `ast::BinaryOp` in the current scope
    --> src/quality/linter.rs:1760:27
     |
1760 |             op: BinaryOp::Gt,
     |                           ^^ variant or associated item not found in `ast::BinaryOp`
     |
    ::: src/frontend/ast.rs:378:1
     |
378  | pub enum BinaryOp {
     | ----------------- variant or associated item `Gt` not found for this enum

error[E0599]: no variant or associated item named `Boolean` found for enum `ast::Literal` in the current scope
    --> src/quality/linter.rs:2020:74
     |
2020 |                 condition: Box::new(Expr::new(ExprKind::Literal(Literal::Boolean(true)), Span { start: 0, end: 1 })),
     |                                                                          ^^^^^^^ variant or associated item not found in `ast::Literal`
     |
    ::: src/frontend/ast.rs:341:1
     |
341  | pub enum Literal {
     | ---------------- variant or associated item `Boolean` not found for this enum
     |
note: if you're trying to build a new `ast::Literal`, consider using `ast::Literal::from_value` which returns `ast::Literal`
    --> src/frontend/ast.rs:351:5
     |
351  |     pub fn from_value(value: &crate::runtime::repl::Value) -> Self {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `stop_session` found for struct `dataflow_debugger::DataflowDebugger` in the current scope
   --> src/runtime/dataflow_debugger.rs:866:31
    |
12  | pub struct DataflowDebugger {
    | --------------------------- method `stop_session` not found for this struct
...
866 |         let result = debugger.stop_session();
    |                               ^^^^^^^^^^^^
    |
help: there is a method `start_session` with a similar name
    |
866 -         let result = debugger.stop_session();
866 +         let result = debugger.start_session();
    |

error[E0599]: no method named `add_stage` found for struct `dataflow_debugger::DataflowDebugger` in the current scope
   --> src/runtime/dataflow_debugger.rs:888:31
    |
12  | pub struct DataflowDebugger {
    | --------------------------- method `add_stage` not found for this struct
...
888 |         let result = debugger.add_stage(stage);
    |                               ^^^^^^^^^ method not found in `dataflow_debugger::DataflowDebugger`

error[E0599]: no method named `set_breakpoint` found for struct `dataflow_debugger::DataflowDebugger` in the current scope
   --> src/runtime/dataflow_debugger.rs:905:31
    |
12  | pub struct DataflowDebugger {
    | --------------------------- method `set_breakpoint` not found for this struct
...
905 |         let result = debugger.set_breakpoint("stage_1".to_string(), breakpoint);
    |                               ^^^^^^^^^^^^^^
    |
help: there is a method `add_breakpoint` with a similar name, but with different arguments
   --> src/runtime/dataflow_debugger.rs:340:5
    |
340 |     pub fn add_breakpoint(&self, breakpoint: Breakpoint) -> Result<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `set_breakpoint` found for struct `dataflow_debugger::DataflowDebugger` in the current scope
   --> src/runtime/dataflow_debugger.rs:922:26
    |
12  | pub struct DataflowDebugger {
    | --------------------------- method `set_breakpoint` not found for this struct
...
922 |         let _ = debugger.set_breakpoint("stage_1".to_string(), breakpoint);
    |                          ^^^^^^^^^^^^^^
    |
help: there is a method `add_breakpoint` with a similar name, but with different arguments
   --> src/runtime/dataflow_debugger.rs:340:5
    |
340 |     pub fn add_breakpoint(&self, breakpoint: Breakpoint) -> Result<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0560]: struct `dataflow_debugger::StageMetrics` has no field named `stage_id`
    --> src/runtime/dataflow_debugger.rs:1104:13
     |
1104 |             stage_id: "stage_1".to_string(),
     |             ^^^^^^^^ `dataflow_debugger::StageMetrics` does not have this field
     |
     = note: available fields are: `execution_time`, `peak_memory`, `input_rows`, `output_rows`, `cpu_time` ... and 2 others

error[E0560]: struct `dataflow_debugger::StageMetrics` has no field named `execution_count`
    --> src/runtime/dataflow_debugger.rs:1105:13
     |
1105 |             execution_count: 1,
     |             ^^^^^^^^^^^^^^^ unknown field
     |
help: a field with a similar name exists
     |
1105 -             execution_count: 1,
1105 +             execution_time: 1,
     |

error[E0560]: struct `dataflow_debugger::StageMetrics` has no field named `total_execution_time`
    --> src/runtime/dataflow_debugger.rs:1106:13
     |
1106 |             total_execution_time: Duration::from_millis(500),
     |             ^^^^^^^^^^^^^^^^^^^^ unknown field
     |
help: a field with a similar name exists
     |
1106 -             total_execution_time: Duration::from_millis(500),
1106 +             execution_time: Duration::from_millis(500),
     |

error[E0560]: struct `dataflow_debugger::StageMetrics` has no field named `average_execution_time`
    --> src/runtime/dataflow_debugger.rs:1107:13
     |
1107 |             average_execution_time: Duration::from_millis(500),
     |             ^^^^^^^^^^^^^^^^^^^^^^ `dataflow_debugger::StageMetrics` does not have this field
     |
     = note: available fields are: `execution_time`, `peak_memory`, `input_rows`, `output_rows`, `cpu_time` ... and 2 others

error[E0560]: struct `dataflow_debugger::StageMetrics` has no field named `peak_memory_usage`
    --> src/runtime/dataflow_debugger.rs:1108:13
     |
1108 |             peak_memory_usage: 1024,
     |             ^^^^^^^^^^^^^^^^^ `dataflow_debugger::StageMetrics` does not have this field
     |
     = note: available fields are: `execution_time`, `peak_memory`, `input_rows`, `output_rows`, `cpu_time` ... and 2 others

error[E0560]: struct `dataflow_debugger::StageMetrics` has no field named `total_rows_processed`
    --> src/runtime/dataflow_debugger.rs:1109:13
     |
1109 |             total_rows_processed: 10000,
     |             ^^^^^^^^^^^^^^^^^^^^ `dataflow_debugger::StageMetrics` does not have this field
     |
     = note: available fields are: `execution_time`, `peak_memory`, `input_rows`, `output_rows`, `cpu_time` ... and 2 others

error[E0560]: struct `dataflow_debugger::StageMetrics` has no field named `error_count`
    --> src/runtime/dataflow_debugger.rs:1110:13
     |
1110 |             error_count: 0,
     |             ^^^^^^^^^^^ `dataflow_debugger::StageMetrics` does not have this field
     |
     = note: available fields are: `execution_time`, `peak_memory`, `input_rows`, `output_rows`, `cpu_time` ... and 2 others

error[E0560]: struct `dataflow_debugger::StageMetrics` has no field named `last_execution`
    --> src/runtime/dataflow_debugger.rs:1111:13
     |
1111 |             last_execution: std::time::SystemTime::now(),
     |             ^^^^^^^^^^^^^^ `dataflow_debugger::StageMetrics` does not have this field
     |
     = note: available fields are: `execution_time`, `peak_memory`, `input_rows`, `output_rows`, `cpu_time` ... and 2 others

error[E0609]: no field `stage_id` on type `dataflow_debugger::StageMetrics`
    --> src/runtime/dataflow_debugger.rs:1114:28
     |
1114 |         assert_eq!(metrics.stage_id, "stage_1");
     |                            ^^^^^^^^ unknown field
     |
     = note: available fields are: `execution_time`, `peak_memory`, `input_rows`, `output_rows`, `cpu_time` ... and 2 others

error[E0609]: no field `execution_count` on type `dataflow_debugger::StageMetrics`
    --> src/runtime/dataflow_debugger.rs:1115:28
     |
1115 |         assert_eq!(metrics.execution_count, 1);
     |                            ^^^^^^^^^^^^^^^ unknown field
     |
help: a field with a similar name exists
     |
1115 -         assert_eq!(metrics.execution_count, 1);
1115 +         assert_eq!(metrics.execution_time, 1);
     |

error[E0609]: no field `total_rows_processed` on type `dataflow_debugger::StageMetrics`
    --> src/runtime/dataflow_debugger.rs:1116:28
     |
1116 |         assert_eq!(metrics.total_rows_processed, 10000);
     |                            ^^^^^^^^^^^^^^^^^^^^ unknown field
     |
     = note: available fields are: `execution_time`, `peak_memory`, `input_rows`, `output_rows`, `cpu_time` ... and 2 others

error[E0609]: no field `error_count` on type `dataflow_debugger::StageMetrics`
    --> src/runtime/dataflow_debugger.rs:1117:28
     |
1117 |         assert_eq!(metrics.error_count, 0);
     |                            ^^^^^^^^^^^ unknown field
     |
     = note: available fields are: `execution_time`, `peak_memory`, `input_rows`, `output_rows`, `cpu_time` ... and 2 others

error[E0223]: ambiguous associated type
    --> src/runtime/dataflow_debugger.rs:1122:21
     |
1122 |         let event = ExecutionEvent::StageStart {
     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
     |
help: if there were a trait named `Example` with associated type `StageStart` implemented for `dataflow_debugger::ExecutionEvent`, you could use the fully-qualified path
     |
1122 -         let event = ExecutionEvent::StageStart {
1122 +         let event = <dataflow_debugger::ExecutionEvent as Example>::StageStart {
     |

error[E0223]: ambiguous associated type
    --> src/runtime/dataflow_debugger.rs:1127:16
     |
1127 |         if let ExecutionEvent::StageStart { stage_id, .. } = event {
     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^
     |
help: if there were a trait named `Example` with associated type `StageStart` implemented for `dataflow_debugger::ExecutionEvent`, you could use the fully-qualified path
     |
1127 -         if let ExecutionEvent::StageStart { stage_id, .. } = event {
1127 +         if let <dataflow_debugger::ExecutionEvent as Example>::StageStart { stage_id, .. } = event {
     |

error[E0223]: ambiguous associated type
    --> src/runtime/dataflow_debugger.rs:1136:21
     |
1136 |         let event = ExecutionEvent::StageComplete {
     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     |
help: if there were a trait named `Example` with associated type `StageComplete` implemented for `dataflow_debugger::ExecutionEvent`, you could use the fully-qualified path
     |
1136 -         let event = ExecutionEvent::StageComplete {
1136 +         let event = <dataflow_debugger::ExecutionEvent as Example>::StageComplete {
     |

error[E0223]: ambiguous associated type
    --> src/runtime/dataflow_debugger.rs:1143:16
     |
1143 |         if let ExecutionEvent::StageComplete { stage_id, rows_processed, .. } = event {
     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     |
help: if there were a trait named `Example` with associated type `StageComplete` implemented for `dataflow_debugger::ExecutionEvent`, you could use the fully-qualified path
     |
1143 -         if let ExecutionEvent::StageComplete { stage_id, rows_processed, .. } = event {
1143 +         if let <dataflow_debugger::ExecutionEvent as Example>::StageComplete { stage_id, rows_processed, .. } = event {
     |

error[E0223]: ambiguous associated type
    --> src/runtime/dataflow_debugger.rs:1153:21
     |
1153 |         let event = ExecutionEvent::BreakpointHit {
     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     |
help: if there were a trait named `Example` with associated type `BreakpointHit` implemented for `dataflow_debugger::ExecutionEvent`, you could use the fully-qualified path
     |
1153 -         let event = ExecutionEvent::BreakpointHit {
1153 +         let event = <dataflow_debugger::ExecutionEvent as Example>::BreakpointHit {
     |

error[E0223]: ambiguous associated type
    --> src/runtime/dataflow_debugger.rs:1159:16
     |
1159 |         if let ExecutionEvent::BreakpointHit { stage_id, breakpoint_id, .. } = event {
     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     |
help: if there were a trait named `Example` with associated type `BreakpointHit` implemented for `dataflow_debugger::ExecutionEvent`, you could use the fully-qualified path
     |
1159 -         if let ExecutionEvent::BreakpointHit { stage_id, breakpoint_id, .. } = event {
1159 +         if let <dataflow_debugger::ExecutionEvent as Example>::BreakpointHit { stage_id, breakpoint_id, .. } = event {
     |

error[E0223]: ambiguous associated type
    --> src/runtime/dataflow_debugger.rs:1169:21
     |
1169 |         let event = ExecutionEvent::Error {
     |                     ^^^^^^^^^^^^^^^^^^^^^
     |
help: use fully-qualified syntax
     |
1169 -         let event = ExecutionEvent::Error {
1169 +         let event = <dataflow_debugger::ExecutionEvent as TryFrom>::Error {
     |
1169 -         let event = ExecutionEvent::Error {
1169 +         let event = <dataflow_debugger::ExecutionEvent as TryInto>::Error {
     |
1169 -         let event = ExecutionEvent::Error {
1169 +         let event = <dataflow_debugger::ExecutionEvent as ciborium_io::Read>::Error {
     |
1169 -         let event = ExecutionEvent::Error {
1169 +         let event = <dataflow_debugger::ExecutionEvent as ciborium_io::Write>::Error {
     |
       and 8 other candidates

error[E0223]: ambiguous associated type
    --> src/runtime/dataflow_debugger.rs:1175:16
     |
1175 |         if let ExecutionEvent::Error { stage_id, error_message, .. } = event {
     |                ^^^^^^^^^^^^^^^^^^^^^
     |
help: use fully-qualified syntax
     |
1175 -         if let ExecutionEvent::Error { stage_id, error_message, .. } = event {
1175 +         if let <dataflow_debugger::ExecutionEvent as TryFrom>::Error { stage_id, error_message, .. } = event {
     |
1175 -         if let ExecutionEvent::Error { stage_id, error_message, .. } = event {
1175 +         if let <dataflow_debugger::ExecutionEvent as TryInto>::Error { stage_id, error_message, .. } = event {
     |
1175 -         if let ExecutionEvent::Error { stage_id, error_message, .. } = event {
1175 +         if let <dataflow_debugger::ExecutionEvent as ciborium_io::Read>::Error { stage_id, error_message, .. } = event {
     |
1175 -         if let ExecutionEvent::Error { stage_id, error_message, .. } = event {
1175 +         if let <dataflow_debugger::ExecutionEvent as ciborium_io::Write>::Error { stage_id, error_message, .. } = event {
     |
       and 8 other candidates

error[E0599]: no variant or associated item named `Arrow` found for enum `dataflow_debugger::ExportFormat` in the current scope
    --> src/runtime/dataflow_debugger.rs:1203:27
     |
289  | pub enum ExportFormat {
     | --------------------- variant or associated item `Arrow` not found for this enum
...
1203 |             ExportFormat::Arrow,
     |                           ^^^^^ variant or associated item not found in `dataflow_debugger::ExportFormat`

error[E0308]: mismatched types
   --> src/runtime/pattern_matching.rs:535:30
    |
535 |                     pattern: Pattern::Identifier("person_name".to_string()),
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Option<Pattern>`, found `Pattern`
    |
    = note: expected enum `std::option::Option<ast::Pattern>`
               found enum `ast::Pattern`
help: try wrapping the expression in `Some`
    |
535 |                     pattern: Some(Pattern::Identifier("person_name".to_string())),
    |                              +++++                                              +

error[E0560]: struct `ast::StructPatternField` has no field named `default_value`
   --> src/runtime/pattern_matching.rs:536:21
    |
536 |                     default_value: None,
    |                     ^^^^^^^^^^^^^ `ast::StructPatternField` does not have this field
    |
    = note: all struct fields are already assigned

error[E0308]: mismatched types
   --> src/runtime/pattern_matching.rs:540:30
    |
540 |                     pattern: Pattern::Identifier("person_age".to_string()),
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Option<Pattern>`, found `Pattern`
    |
    = note: expected enum `std::option::Option<ast::Pattern>`
               found enum `ast::Pattern`
help: try wrapping the expression in `Some`
    |
540 |                     pattern: Some(Pattern::Identifier("person_age".to_string())),
    |                              +++++                                             +

error[E0560]: struct `ast::StructPatternField` has no field named `default_value`
   --> src/runtime/pattern_matching.rs:541:21
    |
541 |                     default_value: None,
    |                     ^^^^^^^^^^^^^ `ast::StructPatternField` does not have this field
    |
    = note: all struct fields are already assigned

error[E0063]: missing field `has_rest` in initializer of `ast::Pattern`
   --> src/runtime/pattern_matching.rs:530:30
    |
530 |         let struct_pattern = Pattern::Struct {
    |                              ^^^^^^^^^^^^^^^ missing `has_rest`

error[E0308]: mismatched types
   --> src/runtime/observatory.rs:680:31
    |
680 |                 mailbox_size: i * 10, // 10, 20, 30, 40, 50
    |                               ^^^^^^ expected `usize`, found `u64`

error[E0560]: struct `observatory::MessageStats` has no field named `total_failed`
   --> src/runtime/observatory.rs:685:21
    |
685 |                     total_failed: i * 2,       // 2, 4, 6, 8, 10
    |                     ^^^^^^^^^^^^ `observatory::MessageStats` does not have this field
    |
    = note: available fields are: `messages_per_second`, `max_processing_time_us`, `failed_messages`, `last_processed`

error[E0277]: cannot multiply `u64` by `{float}`
   --> src/runtime/observatory.rs:686:47
    |
686 |                     avg_processing_time_us: i * 1000.0, // 1000, 2000, 3000, 4000, 5000
    |                                               ^ no implementation for `u64 * {float}`
    |
    = help: the trait `Mul<{float}>` is not implemented for `u64`
    = help: the following other types implement trait `Mul<Rhs>`:
              `&u64` implements `Mul<u64>`
              `&u64` implements `Mul`
              `u64` implements `Mul<&u64>`
              `u64` implements `Mul<zerocopy::byteorder::U64<O>>`
              `u64` implements `Mul`

error[E0560]: struct `observatory::MessageStats` has no field named `last_message_time`
   --> src/runtime/observatory.rs:687:21
    |
687 |                     last_message_time: Some(current_timestamp()),
    |                     ^^^^^^^^^^^^^^^^^ `observatory::MessageStats` does not have this field
    |
    = note: available fields are: `messages_per_second`, `max_processing_time_us`, `failed_messages`, `last_processed`

error[E0308]: mismatched types
   --> src/runtime/observatory.rs:689:36
    |
689 |                 memory_usage: Some(i * 1024), // 1024, 2048, 3072, 4096, 5120
    |                               ---- ^^^^^^^^ expected `usize`, found `u64`
    |                               |
    |                               arguments to this enum variant are incorrect
    |
help: the type constructed contains `u64` due to the type of the argument passed
   --> src/runtime/observatory.rs:689:31
    |
689 |                 memory_usage: Some(i * 1024), // 1024, 2048, 3072, 4096, 5120
    |                               ^^^^^--------^
    |                                    |
    |                                    this argument influences the type of `Some`
note: tuple variant defined here
   --> /home/noah/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:599:5
    |
599 |     Some(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^^^
help: you can convert a `u64` to a `usize` and panic if the converted value doesn't fit
    |
689 |                 memory_usage: Some((i * 1024).try_into().unwrap()), // 1024, 2048, 3072, 4096, 5120
    |                                    +        +++++++++++++++++++++

error[E0308]: mismatched types
   --> src/runtime/observatory.rs:725:30
    |
725 |                 stack_depth: i,
    |                              ^ expected `usize`, found `u64`

error[E0308]: mismatched types
   --> src/runtime/observatory.rs:868:36
    |
868 |                 memory_usage: Some(1024 * i * i), // Quadratic growth
    |                               ---- ^^^^^^^^^^^^ expected `usize`, found `u64`
    |                               |
    |                               arguments to this enum variant are incorrect
    |
help: the type constructed contains `u64` due to the type of the argument passed
   --> src/runtime/observatory.rs:868:31
    |
868 |                 memory_usage: Some(1024 * i * i), // Quadratic growth
    |                               ^^^^^------------^
    |                                    |
    |                                    this argument influences the type of `Some`
note: tuple variant defined here
   --> /home/noah/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:599:5
    |
599 |     Some(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^^^
help: you can convert a `u64` to a `usize` and panic if the converted value doesn't fit
    |
868 |                 memory_usage: Some((1024 * i * i).try_into().unwrap()), // Quadratic growth
    |                                    +            +++++++++++++++++++++

error[E0308]: mismatched types
   --> src/runtime/observatory.rs:899:30
    |
899 |                 stack_depth: i,
    |                              ^ expected `usize`, found `u64`

error[E0308]: mismatched types
   --> src/runtime/observatory.rs:945:61
    |
945 |                     let _traces = obs.get_traces(None, Some(5)).unwrap();
    |                                                        ---- ^ expected `&str`, found integer
    |                                                        |
    |                                                        arguments to this enum variant are incorrect
    |
help: the type constructed contains `{integer}` due to the type of the argument passed
   --> src/runtime/observatory.rs:945:56
    |
945 |                     let _traces = obs.get_traces(None, Some(5)).unwrap();
    |                                                        ^^^^^-^
    |                                                             |
    |                                                             this argument influences the type of `Some`
note: tuple variant defined here
   --> /home/noah/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:599:5
    |
599 |     Some(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^^^

error[E0308]: mismatched types
   --> src/runtime/observatory.rs:976:42
    |
976 |                 mailbox_size: if i < 4 { i * 2 } else { 0 }, // Clears before crash
    |                                          ^^^^^ expected `usize`, found `u64`
    |
help: you can convert a `u64` to a `usize` and panic if the converted value doesn't fit
    |
976 |                 mailbox_size: if i < 4 { (i * 2).try_into().unwrap() } else { 0 }, // Clears before crash
    |                                          +     +++++++++++++++++++++

error[E0560]: struct `observatory::MessageStats` has no field named `total_failed`
   --> src/runtime/observatory.rs:981:21
    |
981 |                     total_failed: if i >= 4 { i } else { 0 },
    |                     ^^^^^^^^^^^^ `observatory::MessageStats` does not have this field
    |
    = note: available fields are: `messages_per_second`, `max_processing_time_us`, `failed_messages`, `last_processed`

error[E0560]: struct `observatory::MessageStats` has no field named `last_message_time`
   --> src/runtime/observatory.rs:983:21
    |
983 |                     last_message_time: Some(base_time + (i * 10000)),
    |                     ^^^^^^^^^^^^^^^^^ `observatory::MessageStats` does not have this field
    |
    = note: available fields are: `messages_per_second`, `max_processing_time_us`, `failed_messages`, `last_processed`

error[E0308]: mismatched types
   --> src/runtime/observatory.rs:985:36
    |
985 |                 memory_usage: Some(1024 * i),
    |                               ---- ^^^^^^^^ expected `usize`, found `u64`
    |                               |
    |                               arguments to this enum variant are incorrect
    |
help: the type constructed contains `u64` due to the type of the argument passed
   --> src/runtime/observatory.rs:985:31
    |
985 |                 memory_usage: Some(1024 * i),
    |                               ^^^^^--------^
    |                                    |
    |                                    this argument influences the type of `Some`
note: tuple variant defined here
   --> /home/noah/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:599:5
    |
599 |     Some(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^^^
help: you can convert a `u64` to a `usize` and panic if the converted value doesn't fit
    |
985 |                 memory_usage: Some((1024 * i).try_into().unwrap()),
    |                                    +        +++++++++++++++++++++

error[E0609]: no field `total_failed` on type `observatory::MessageStats`
   --> src/runtime/observatory.rs:995:49
    |
995 |         assert_eq!(final_snapshot.message_stats.total_failed, 5);
    |                                                 ^^^^^^^^^^^^ unknown field
    |
    = note: available fields are: `total_processed`, `messages_per_second`, `avg_processing_time_us`, `max_processing_time_us`, `failed_messages`, `last_processed`

error[E0308]: mismatched types
    --> src/runtime/observatory.rs:1259:30
     |
1259 |                 stack_depth: depth,
     |                              ^^^^^ expected `usize`, found `u64`

error[E0308]: mismatched types
    --> src/runtime/observatory.rs:1401:31
     |
1401 |                 mailbox_size: i * 2,
     |                               ^^^^^ expected `usize`, found `u64`

error[E0560]: struct `observatory::MessageStats` has no field named `total_failed`
    --> src/runtime/observatory.rs:1406:21
     |
1406 |                     total_failed: if i % 2 == 0 { 1 } else { 0 },
     |                     ^^^^^^^^^^^^ `observatory::MessageStats` does not have this field
     |
     = note: available fields are: `messages_per_second`, `max_processing_time_us`, `failed_messages`, `last_processed`

error[E0560]: struct `observatory::MessageStats` has no field named `last_message_time`
    --> src/runtime/observatory.rs:1408:21
     |
1408 |                     last_message_time: Some(current_timestamp()),
     |                     ^^^^^^^^^^^^^^^^^ `observatory::MessageStats` does not have this field
     |
     = note: available fields are: `messages_per_second`, `max_processing_time_us`, `failed_messages`, `last_processed`

error[E0308]: mismatched types
    --> src/runtime/observatory.rs:1410:36
     |
1410 |                 memory_usage: Some(1024 * i),
     |                               ---- ^^^^^^^^ expected `usize`, found `u64`
     |                               |
     |                               arguments to this enum variant are incorrect
     |
help: the type constructed contains `u64` due to the type of the argument passed
    --> src/runtime/observatory.rs:1410:31
     |
1410 |                 memory_usage: Some(1024 * i),
     |                               ^^^^^--------^
     |                                    |
     |                                    this argument influences the type of `Some`
note: tuple variant defined here
    --> /home/noah/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:599:5
     |
599  |     Some(#[stable(feature = "rust1", since = "1.0.0")] T),
     |     ^^^^
help: you can convert a `u64` to a `usize` and panic if the converted value doesn't fit
     |
1410 |                 memory_usage: Some((1024 * i).try_into().unwrap()),
     |                                    +        +++++++++++++++++++++

error[E0609]: no field `session_id` on type `runtime::repl::Repl`
    --> src/runtime/repl.rs:9926:25
     |
9926 |         assert_eq!(repl.session_id, 0);
     |                         ^^^^^^^^^^ unknown field
     |
     = note: available fields are: `history`, `result_history`, `definitions`, `bindings`, `binding_mutability` ... and 15 others

error[E0609]: no field `transpiler_cache` on type `runtime::repl::Repl`
    --> src/runtime/repl.rs:9927:22
     |
9927 |         assert!(repl.transpiler_cache.is_empty());
     |                      ^^^^^^^^^^^^^^^^ unknown field
     |
     = note: available fields are: `history`, `result_history`, `definitions`, `bindings`, `binding_mutability` ... and 15 others

error[E0599]: no method named `handle_input` found for struct `runtime::repl::Repl` in the current scope
     --> src/runtime/repl.rs:10079:27
      |
552   | pub struct Repl {
      | --------------- method `handle_input` not found for this struct
...
10079 |         let result = repl.handle_input(":help");
      |                           ^^^^^^^^^^^^ method not found in `runtime::repl::Repl`

error[E0599]: no method named `handle_input` found for struct `runtime::repl::Repl` in the current scope
     --> src/runtime/repl.rs:10084:27
      |
552   | pub struct Repl {
      | --------------- method `handle_input` not found for this struct
...
10084 |         let result = repl.handle_input(":type x");
      |                           ^^^^^^^^^^^^ method not found in `runtime::repl::Repl`

error[E0599]: no method named `handle_input` found for struct `runtime::repl::Repl` in the current scope
     --> src/runtime/repl.rs:10094:27
      |
552   | pub struct Repl {
      | --------------- method `handle_input` not found for this struct
...
10094 |         let result = repl.handle_input(":save test_session");
      |                           ^^^^^^^^^^^^ method not found in `runtime::repl::Repl`

error[E0599]: no method named `handle_input` found for struct `runtime::repl::Repl` in the current scope
     --> src/runtime/repl.rs:10098:27
      |
552   | pub struct Repl {
      | --------------- method `handle_input` not found for this struct
...
10098 |         let result = repl.handle_input(":clear");
      |                           ^^^^^^^^^^^^ method not found in `runtime::repl::Repl`

error[E0609]: no field `input_history` on type `runtime::repl::Repl`
     --> src/runtime/repl.rs:10112:22
      |
10112 |         assert!(repl.input_history.len() >= 2 || repl.input_history.is_empty());
      |                      ^^^^^^^^^^^^^ unknown field
      |
help: a field with a similar name exists
      |
10112 -         assert!(repl.input_history.len() >= 2 || repl.input_history.is_empty());
10112 +         assert!(repl.result_history.len() >= 2 || repl.input_history.is_empty());
      |

error[E0609]: no field `input_history` on type `runtime::repl::Repl`
     --> src/runtime/repl.rs:10112:55
      |
10112 |         assert!(repl.input_history.len() >= 2 || repl.input_history.is_empty());
      |                                                       ^^^^^^^^^^^^^ unknown field
      |
help: a field with a similar name exists
      |
10112 -         assert!(repl.input_history.len() >= 2 || repl.input_history.is_empty());
10112 +         assert!(repl.input_history.len() >= 2 || repl.result_history.is_empty());
      |

error[E0609]: no field `transpiler_cache` on type `runtime::repl::Repl`
     --> src/runtime/repl.rs:10125:22
      |
10125 |         assert!(repl.transpiler_cache.len() >= 0);
      |                      ^^^^^^^^^^^^^^^^ unknown field
      |
      = note: available fields are: `history`, `result_history`, `definitions`, `bindings`, `binding_mutability` ... and 15 others

error[E0599]: no method named `is_magic_command` found for struct `runtime::repl::Repl` in the current scope
     --> src/runtime/repl.rs:10158:22
      |
552   | pub struct Repl {
      | --------------- method `is_magic_command` not found for this struct
...
10158 |         assert!(repl.is_magic_command(":help"));
      |                      ^^^^^^^^^^^^^^^^
      |
help: there is a method `handle_magic_command` with a similar name
      |
10158 -         assert!(repl.is_magic_command(":help"));
10158 +         assert!(repl.handle_magic_command(":help"));
      |

error[E0599]: no method named `is_magic_command` found for struct `runtime::repl::Repl` in the current scope
     --> src/runtime/repl.rs:10159:22
      |
552   | pub struct Repl {
      | --------------- method `is_magic_command` not found for this struct
...
10159 |         assert!(repl.is_magic_command(":type x"));
      |                      ^^^^^^^^^^^^^^^^
      |
help: there is a method `handle_magic_command` with a similar name
      |
10159 -         assert!(repl.is_magic_command(":type x"));
10159 +         assert!(repl.handle_magic_command(":type x"));
      |

error[E0599]: no method named `is_magic_command` found for struct `runtime::repl::Repl` in the current scope
     --> src/runtime/repl.rs:10160:23
      |
552   | pub struct Repl {
      | --------------- method `is_magic_command` not found for this struct
...
10160 |         assert!(!repl.is_magic_command("let x = 5"));
      |                       ^^^^^^^^^^^^^^^^
      |
help: there is a method `handle_magic_command` with a similar name
      |
10160 -         assert!(!repl.is_magic_command("let x = 5"));
10160 +         assert!(!repl.handle_magic_command("let x = 5"));
      |

error[E0599]: no method named `is_load_command` found for struct `runtime::repl::Repl` in the current scope
     --> src/runtime/repl.rs:10161:22
      |
552   | pub struct Repl {
      | --------------- method `is_load_command` not found for this struct
...
10161 |         assert!(repl.is_load_command(":load file.ruchy"));
      |                      ^^^^^^^^^^^^^^^
      |
help: there is a method `handle_load_command` with a similar name
      |
10161 -         assert!(repl.is_load_command(":load file.ruchy"));
10161 +         assert!(repl.handle_load_command(":load file.ruchy"));
      |

error[E0599]: no method named `is_load_command` found for struct `runtime::repl::Repl` in the current scope
     --> src/runtime/repl.rs:10162:23
      |
552   | pub struct Repl {
      | --------------- method `is_load_command` not found for this struct
...
10162 |         assert!(!repl.is_load_command("load(file)"));
      |                       ^^^^^^^^^^^^^^^
      |
help: there is a method `handle_load_command` with a similar name
      |
10162 -         assert!(!repl.is_load_command("load(file)"));
10162 +         assert!(!repl.handle_load_command("load(file)"));
      |

error[E0560]: struct `replay::Environment` has no field named `config`
   --> src/runtime/replay.rs:390:13
    |
390 |             config: HashMap::new(),
    |             ^^^^^^ `replay::Environment` does not have this field
    |
    = note: available fields are: `feature_flags`, `resource_limits`

error[E0560]: struct `replay::Environment` has no field named `global_imports`
   --> src/runtime/replay.rs:391:13
    |
391 |             global_imports: vec![],
    |             ^^^^^^^^^^^^^^ `replay::Environment` does not have this field
    |
    = note: available fields are: `feature_flags`, `resource_limits`

error[E0609]: no field `config` on type `replay::Environment`
   --> src/runtime/replay.rs:459:29
    |
459 |         assert!(environment.config.is_empty());
    |                             ^^^^^^ unknown field
    |
    = note: available fields are: `seed`, `feature_flags`, `resource_limits`

error[E0609]: no field `global_imports` on type `replay::Environment`
   --> src/runtime/replay.rs:460:29
    |
460 |         assert!(environment.global_imports.is_empty());
    |                             ^^^^^^^^^^^^^^ unknown field
    |
    = note: available fields are: `seed`, `feature_flags`, `resource_limits`

error[E0599]: no variant or associated item named `Batch` found for enum `replay::InputMode` in the current scope
   --> src/runtime/replay.rs:666:89
    |
93  | pub enum InputMode {
    | ------------------ variant or associated item `Batch` not found for this enum
...
666 |         let batch_id = recorder.record_input("let batch = true".to_string(), InputMode::Batch);
    |                                                                                         ^^^^^ variant or associated item not found in `replay::InputMode`

error[E0599]: no variant or associated item named `Batch` found for enum `replay::InputMode` in the current scope
   --> src/runtime/replay.rs:675:80
    |
93  | pub enum InputMode {
    | ------------------ variant or associated item `Batch` not found for this enum
...
675 |                     assert!(matches!(mode, InputMode::Interactive | InputMode::Batch));
    |                                                                                ^^^^^ variant or associated item not found in `replay::InputMode`

error[E0599]: no variant named `OutputMismatch` found for enum `replay::Divergence`
   --> src/runtime/replay.rs:716:39
    |
150 | pub enum Divergence {
    | ------------------- variant `OutputMismatch` not found here
...
716 |         let divergence1 = Divergence::OutputMismatch {
    |                                       ^^^^^^^^^^^^^^ variant not found in `replay::Divergence`

error[E0599]: no variant named `StateMismatch` found for enum `replay::Divergence`
   --> src/runtime/replay.rs:722:39
    |
150 | pub enum Divergence {
    | ------------------- variant `StateMismatch` not found here
...
722 |         let divergence2 = Divergence::StateMismatch {
    |                                       ^^^^^^^^^^^^^ variant not found in `replay::Divergence`

error[E0599]: no method named `contains_key` found for struct `Vec<(replay::EventId, replay::Divergence)>` in the current scope
   --> src/runtime/replay.rs:733:36
    |
733 |         assert!(report.divergences.contains_key(&EventId(1)));
    |                                    ^^^^^^^^^^^^
    |
help: there is a method `contains` with a similar name
    |
733 -         assert!(report.divergences.contains_key(&EventId(1)));
733 +         assert!(report.divergences.contains(&EventId(1)));
    |

error[E0599]: no method named `contains_key` found for struct `Vec<(replay::EventId, replay::Divergence)>` in the current scope
   --> src/runtime/replay.rs:734:36
    |
734 |         assert!(report.divergences.contains_key(&EventId(2)));
    |                                    ^^^^^^^^^^^^
    |
help: there is a method `contains` with a similar name
    |
734 -         assert!(report.divergences.contains_key(&EventId(2)));
734 +         assert!(report.divergences.contains(&EventId(2)));
    |

error[E0027]: pattern does not mention fields `stdout`, `stderr`
   --> src/runtime/replay.rs:761:13
    |
761 |             Event::Output { result } => {
    |             ^^^^^^^^^^^^^^^^^^^^^^^^ missing fields `stdout`, `stderr`
    |
help: include the missing fields in the pattern
    |
761 |             Event::Output { result, stdout, stderr } => {
    |                                   ++++++++++++++++
help: if you don't care about these missing fields, you can explicitly ignore them
    |
761 |             Event::Output { result, stdout: _, stderr: _ } => {
    |                                   ++++++++++++++++++++++
help: or always ignore missing fields here
    |
761 |             Event::Output { result, .. } => {
    |                                   ++++

error[E0308]: mismatched types
   --> src/runtime/replay.rs:763:21
    |
762 |                 match result {
    |                       ------ this expression has type `&replay::EvalResult`
763 |                     Err(_) => {}, // Expected error
    |                     ^^^^^^ expected `EvalResult`, found `Result<_, _>`
    |
    = note: expected enum `replay::EvalResult`
               found enum `std::result::Result<_, _>`

error[E0308]: mismatched types
   --> src/runtime/replay.rs:764:21
    |
762 |                 match result {
    |                       ------ this expression has type `&replay::EvalResult`
763 |                     Err(_) => {}, // Expected error
764 |                     Ok(_) => panic!("Expected error result"),
    |                     ^^^^^ expected `EvalResult`, found `Result<_, _>`
    |
    = note: expected enum `replay::EvalResult`
               found enum `std::result::Result<_, _>`

error[E0609]: no field `memory_bytes` on type `replay::ResourceTolerance`
   --> src/runtime/replay.rs:777:27
    |
777 |         assert!(tolerance.memory_bytes > 0);
    |                           ^^^^^^^^^^^^ unknown field
    |
    = note: available fields are: `heap_bytes_percent`, `cpu_ns_percent`

error[E0609]: no field `cpu_ns` on type `replay::ResourceTolerance`
   --> src/runtime/replay.rs:778:27
    |
778 |         assert!(tolerance.cpu_ns > 0);
    |                           ^^^^^^ unknown field
    |
    = note: available fields are: `heap_bytes_percent`, `cpu_ns_percent`

error[E0609]: no field `stack_depth` on type `replay::ResourceTolerance`
   --> src/runtime/replay.rs:779:27
    |
779 |         assert!(tolerance.stack_depth > 0);
    |                           ^^^^^^^^^^^ unknown field
    |
    = note: available fields are: `heap_bytes_percent`, `cpu_ns_percent`

error[E0560]: struct `replay::ResourceTolerance` has no field named `memory_bytes`
   --> src/runtime/replay.rs:783:13
    |
783 |             memory_bytes: 1024,
    |             ^^^^^^^^^^^^ `replay::ResourceTolerance` does not have this field
    |
    = note: available fields are: `heap_bytes_percent`, `cpu_ns_percent`

error[E0560]: struct `replay::ResourceTolerance` has no field named `cpu_ns`
   --> src/runtime/replay.rs:784:13
    |
784 |             cpu_ns: 1000000,
    |             ^^^^^^ `replay::ResourceTolerance` does not have this field
    |
    = note: available fields are: `heap_bytes_percent`, `cpu_ns_percent`

error[E0560]: struct `replay::ResourceTolerance` has no field named `stack_depth`
   --> src/runtime/replay.rs:785:13
    |
785 |             stack_depth: 10,
    |             ^^^^^^^^^^^ `replay::ResourceTolerance` does not have this field
    |
    = note: available fields are: `heap_bytes_percent`, `cpu_ns_percent`

error[E0609]: no field `memory_bytes` on type `replay::ResourceTolerance`
   --> src/runtime/replay.rs:788:37
    |
788 |         assert_eq!(custom_tolerance.memory_bytes, 1024);
    |                                     ^^^^^^^^^^^^ unknown field
    |
    = note: available fields are: `heap_bytes_percent`, `cpu_ns_percent`

error[E0609]: no field `cpu_ns` on type `replay::ResourceTolerance`
   --> src/runtime/replay.rs:789:37
    |
789 |         assert_eq!(custom_tolerance.cpu_ns, 1000000);
    |                                     ^^^^^^ unknown field
    |
    = note: available fields are: `heap_bytes_percent`, `cpu_ns_percent`

error[E0609]: no field `stack_depth` on type `replay::ResourceTolerance`
   --> src/runtime/replay.rs:790:37
    |
790 |         assert_eq!(custom_tolerance.stack_depth, 10);
    |                                     ^^^^^^^^^^^ unknown field
    |
    = note: available fields are: `heap_bytes_percent`, `cpu_ns_percent`

error[E0599]: no associated item named `Percent` found for struct `assessment::LatePenalty` in the current scope
   --> src/runtime/assessment.rs:861:44
    |
138 | pub struct LatePenalty {
    | ---------------------- associated item `Percent` not found for this struct
...
861 |                 late_penalty: LatePenalty::Percent(10),
    |                                            ^^^^^^^ associated item not found in `assessment::LatePenalty`

error[E0063]: missing field `bonus_criteria` in initializer of `assessment::GradingRubric`
   --> src/runtime/assessment.rs:859:21
    |
859 |             rubric: GradingRubric {
    |                     ^^^^^^^^^^^^^ missing `bonus_criteria`

error[E0560]: struct `assessment::Criterion` has no field named `points`
   --> src/runtime/assessment.rs:965:29
    |
965 | ...                   points: 50,
    |                       ^^^^^^ `assessment::Criterion` does not have this field
    |
    = note: available fields are: `max_points`, `evaluation`

error[E0560]: struct `assessment::Criterion` has no field named `partial_credit`
   --> src/runtime/assessment.rs:966:29
    |
966 | ...                   partial_credit: true,
    |                       ^^^^^^^^^^^^^^ `assessment::Criterion` does not have this field
    |
    = note: available fields are: `max_points`, `evaluation`

error[E0599]: no associated item named `Fixed` found for struct `assessment::LatePenalty` in the current scope
   --> src/runtime/assessment.rs:976:40
    |
138 | pub struct LatePenalty {
    | ---------------------- associated item `Fixed` not found for this struct
...
976 |             late_penalty: LatePenalty::Fixed(5),
    |                                        ^^^^^ associated item not found in `assessment::LatePenalty`

error[E0063]: missing field `bonus_criteria` in initializer of `assessment::GradingRubric`
   --> src/runtime/assessment.rs:957:22
    |
957 |         let rubric = GradingRubric {
    |                      ^^^^^^^^^^^^^ missing `bonus_criteria`

error[E0599]: no associated item named `Fixed` found for struct `assessment::LatePenalty` in the current scope
   --> src/runtime/assessment.rs:983:26
    |
138 | pub struct LatePenalty {
    | ---------------------- associated item `Fixed` not found for this struct
...
983 |             LatePenalty::Fixed(p) => assert_eq!(p, 5),
    |                          ^^^^^ associated item not found in `assessment::LatePenalty`

error[E0599]: no associated item named `None` found for struct `assessment::LatePenalty` in the current scope
    --> src/runtime/assessment.rs:1028:44
     |
138  | pub struct LatePenalty {
     | ---------------------- associated item `None` not found for this struct
...
1028 |                 late_penalty: LatePenalty::None,
     |                                            ^^^^ associated item not found in `assessment::LatePenalty`

error[E0063]: missing field `bonus_criteria` in initializer of `assessment::GradingRubric`
    --> src/runtime/assessment.rs:1026:21
     |
1026 |             rubric: GradingRubric {
     |                     ^^^^^^^^^^^^^ missing `bonus_criteria`

error[E0433]: failed to resolve: use of undeclared type `AutoGrader`
    --> src/runtime/assessment.rs:1032:22
     |
1032 |         let grader = AutoGrader::new(assignment);
     |                      ^^^^^^^^^^ use of undeclared type `AutoGrader`

error[E0560]: struct `assessment::Criterion` has no field named `points`
    --> src/runtime/assessment.rs:1046:13
     |
1046 |             points: 25,
     |             ^^^^^^ `assessment::Criterion` does not have this field
     |
     = note: available fields are: `max_points`, `evaluation`

error[E0560]: struct `assessment::Criterion` has no field named `partial_credit`
    --> src/runtime/assessment.rs:1047:13
     |
1047 |             partial_credit: true,
     |             ^^^^^^^^^^^^^^ `assessment::Criterion` does not have this field
     |
     = note: available fields are: `max_points`, `evaluation`

error[E0609]: no field `points` on type `assessment::Criterion`
    --> src/runtime/assessment.rs:1051:30
     |
1051 |         assert_eq!(criterion.points, 25);
     |                              ^^^^^^ unknown field
     |
     = note: available fields are: `description`, `max_points`, `evaluation`

error[E0609]: no field `partial_credit` on type `assessment::Criterion`
    --> src/runtime/assessment.rs:1052:27
     |
1052 |         assert!(criterion.partial_credit);
     |                           ^^^^^^^^^^^^^^ unknown field
     |
     = note: available fields are: `description`, `max_points`, `evaluation`

error[E0560]: struct `assessment::Criterion` has no field named `points`
    --> src/runtime/assessment.rs:1056:13
     |
1056 |             points: 10,
     |             ^^^^^^ `assessment::Criterion` does not have this field
     |
     = note: available fields are: `max_points`, `evaluation`

error[E0560]: struct `assessment::Criterion` has no field named `partial_credit`
    --> src/runtime/assessment.rs:1057:13
     |
1057 |             partial_credit: false,
     |             ^^^^^^^^^^^^^^ `assessment::Criterion` does not have this field
     |
     = note: available fields are: `max_points`, `evaluation`

error[E0609]: no field `partial_credit` on type `assessment::Criterion`
    --> src/runtime/assessment.rs:1060:29
     |
1060 |         assert!(!no_partial.partial_credit);
     |                             ^^^^^^^^^^^^^^ unknown field
     |
     = note: available fields are: `description`, `max_points`, `evaluation`

error[E0433]: failed to resolve: use of undeclared type `AcademicIntegrityDetector`
    --> src/runtime/assessment.rs:1065:24
     |
1065 |         let detector = AcademicIntegrityDetector::new();
     |                        ^^^^^^^^^^^^^^^^^^^^^^^^^ use of undeclared type `AcademicIntegrityDetector`

error[E0308]: mismatched types
   --> src/runtime/magic.rs:773:29
    |
773 |             function_times: std::collections::HashMap::new(),
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Vec<(String, Duration, usize)>`, found `HashMap<_, _>`
    |
    = note: expected struct `Vec<(std::string::String, std::time::Duration, usize)>`
               found struct `std::collections::HashMap<_, _>`

error[E0560]: struct `magic::ProfileData` has no field named `memory_usage`
   --> src/runtime/magic.rs:774:13
    |
774 |             memory_usage: 1024,
    |             ^^^^^^^^^^^^ `magic::ProfileData` does not have this field
    |
    = note: all struct fields are already assigned

error[E0308]: mismatched types
    --> src/runtime/magic.rs:1000:13
     |
1000 |             function_times,
     |             ^^^^^^^^^^^^^^ expected `Vec<(String, Duration, usize)>`, found `HashMap<String, Duration>`
     |
     = note: expected struct `Vec<(std::string::String, std::time::Duration, usize)>`
                found struct `std::collections::HashMap<std::string::String, std::time::Duration>`

error[E0560]: struct `magic::ProfileData` has no field named `memory_usage`
    --> src/runtime/magic.rs:1001:13
     |
1001 |             memory_usage: 2048,
     |             ^^^^^^^^^^^^ `magic::ProfileData` does not have this field
     |
     = note: all struct fields are already assigned

error[E0609]: no field `memory_usage` on type `magic::ProfileData`
    --> src/runtime/magic.rs:1005:28
     |
1005 |         assert_eq!(profile.memory_usage, 2048);
     |                            ^^^^^^^^^^^^ unknown field
     |
     = note: available fields are: `total_time`, `function_times`

error[E0308]: mismatched types
    --> src/runtime/magic.rs:1016:13
     |
1016 |             function_times,
     |             ^^^^^^^^^^^^^^ expected `Vec<(String, Duration, usize)>`, found `HashMap<String, Duration>`
     |
     = note: expected struct `Vec<(std::string::String, std::time::Duration, usize)>`
                found struct `std::collections::HashMap<std::string::String, std::time::Duration>`

error[E0560]: struct `magic::ProfileData` has no field named `memory_usage`
    --> src/runtime/magic.rs:1017:13
     |
1017 |             memory_usage: 1024,
     |             ^^^^^^^^^^^^ `magic::ProfileData` does not have this field
     |
     = note: all struct fields are already assigned

error[E0560]: struct `ast::Param` has no field named `name`
   --> src/testing/ast_builder.rs:891:26
    |
891 |             vec![Param { name: "x".to_string(), type_annotation: None }],
    |                          ^^^^ `ast::Param` does not have this field
    |
    = note: available fields are: `pattern`, `ty`, `span`, `is_mutable`, `default_value`

error[E0560]: struct `ast::Param` has no field named `type_annotation`
   --> src/testing/ast_builder.rs:891:49
    |
891 |             vec![Param { name: "x".to_string(), type_annotation: None }],
    |                                                 ^^^^^^^^^^^^^^^ `ast::Param` does not have this field
    |
    = note: available fields are: `pattern`, `ty`, `span`, `is_mutable`, `default_value`

error[E0615]: attempted to take value of method `name` on type `ast::Param`
   --> src/testing/ast_builder.rs:897:34
    |
897 |             assert_eq!(params[0].name, "x");
    |                                  ^^^^ method, not a field
    |
help: use parentheses to call the method
    |
897 |             assert_eq!(params[0].name(), "x");
    |                                      ++

error[E0609]: no field `type_annotation` on type `ast::Param`
   --> src/testing/ast_builder.rs:898:31
    |
898 |             assert!(params[0].type_annotation.is_none());
    |                               ^^^^^^^^^^^^^^^ unknown field
    |
    = note: available fields are: `pattern`, `ty`, `span`, `is_mutable`, `default_value`

error[E0308]: mismatched types
    --> src/testing/ast_builder.rs:1577:30
     |
1577 |             StringPart::Expr(builder.ident("name")),
     |             ---------------- ^^^^^^^^^^^^^^^^^^^^^ expected `Box<Expr>`, found `Expr`
     |             |
     |             arguments to this enum variant are incorrect
     |
     = note: expected struct `Box<ast::Expr>`
                found struct `ast::Expr`
     = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html
note: tuple variant defined here
    --> src/frontend/ast.rs:370:5
     |
370  |     Expr(Box<Expr>),
     |     ^^^^
help: store this in the heap by calling `Box::new`
     |
1577 |             StringPart::Expr(Box::new(builder.ident("name"))),
     |                              +++++++++                     +

error[E0599]: no method named `add_source_file` found for struct `wasm::component::ComponentBuilder` in the current scope
    --> src/wasm/component.rs:1113:17
     |
29   | pub struct ComponentBuilder {
     | --------------------------- method `add_source_file` not found for this struct
...
1113 |         builder.add_source_file("file1.ruchy");
     |                 ^^^^^^^^^^^^^^^
     |
help: there is a method `add_source` with a similar name
     |
1113 -         builder.add_source_file("file1.ruchy");
1113 +         builder.add_source("file1.ruchy");
     |

error[E0599]: no method named `add_source_file` found for struct `wasm::component::ComponentBuilder` in the current scope
    --> src/wasm/component.rs:1114:17
     |
29   | pub struct ComponentBuilder {
     | --------------------------- method `add_source_file` not found for this struct
...
1114 |         builder.add_source_file("file2.ruchy");
     |                 ^^^^^^^^^^^^^^^
     |
help: there is a method `add_source` with a similar name
     |
1114 -         builder.add_source_file("file2.ruchy");
1114 +         builder.add_source("file2.ruchy");
     |

error[E0599]: no method named `add_source_file` found for struct `wasm::component::ComponentBuilder` in the current scope
    --> src/wasm/component.rs:1115:17
     |
29   | pub struct ComponentBuilder {
     | --------------------------- method `add_source_file` not found for this struct
...
1115 |         builder.add_source_file("file3.ruchy");
     |                 ^^^^^^^^^^^^^^^
     |
help: there is a method `add_source` with a similar name
     |
1115 -         builder.add_source_file("file3.ruchy");
1115 +         builder.add_source("file3.ruchy");
     |

error[E0599]: no variant or associated item named `O0` found for enum `wasm::component::OptimizationLevel` in the current scope
    --> src/wasm/component.rs:1126:32
     |
235  | pub enum OptimizationLevel {
     | -------------------------- variant or associated item `O0` not found for this enum
...
1126 |             OptimizationLevel::O0,
     |                                ^^ variant or associated item not found in `wasm::component::OptimizationLevel`
     |
help: there is a variant with a similar name
     |
1126 -             OptimizationLevel::O0,
1126 +             OptimizationLevel::O1,
     |

error[E0599]: no method named `set_optimization_level` found for struct `wasm::component::ComponentBuilder` in the current scope
    --> src/wasm/component.rs:1136:21
     |
29   | pub struct ComponentBuilder {
     | --------------------------- method `set_optimization_level` not found for this struct
...
1136 |             builder.set_optimization_level(level.clone());
     |                     ^^^^^^^^^^^^^^^^^^^^^^
     |
help: there is a method `with_optimization` with a similar name
     |
1136 -             builder.set_optimization_level(level.clone());
1136 +             builder.with_optimization(level.clone());
     |

error[E0599]: no method named `enable_debug_info` found for struct `wasm::component::ComponentBuilder` in the current scope
    --> src/wasm/component.rs:1194:17
     |
29   | pub struct ComponentBuilder {
     | --------------------------- method `enable_debug_info` not found for this struct
...
1194 |         builder.enable_debug_info(true);
     |                 ^^^^^^^^^^^^^^^^^
     |
help: there is a method `with_debug_info` with a similar name
     |
1194 -         builder.enable_debug_info(true);
1194 +         builder.with_debug_info(true);
     |

error[E0599]: no method named `enable_debug_info` found for struct `wasm::component::ComponentBuilder` in the current scope
    --> src/wasm/component.rs:1197:17
     |
29   | pub struct ComponentBuilder {
     | --------------------------- method `enable_debug_info` not found for this struct
...
1197 |         builder.enable_debug_info(false);
     |                 ^^^^^^^^^^^^^^^^^
     |
help: there is a method `with_debug_info` with a similar name
     |
1197 -         builder.enable_debug_info(false);
1197 +         builder.with_debug_info(false);
     |

error[E0560]: struct `shared_session::Edge` has no field named `label`
   --> src/wasm/shared_session.rs:969:13
    |
969 |             label: Some("depends_on".to_string()),
    |             ^^^^^ `shared_session::Edge` does not have this field
    |
    = note: all struct fields are already assigned

error[E0609]: no field `label` on type `shared_session::Edge`
   --> src/wasm/shared_session.rs:974:25
    |
974 |         assert_eq!(edge.label, Some("depends_on".to_string()));
    |                         ^^^^^ unknown field
    |
    = note: available fields are: `from`, `to`

error[E0599]: no method named `is_empty` found for struct `GlobalRegistry` in the current scope
    --> src/wasm/shared_session.rs:1082:33
     |
131  | pub struct GlobalRegistry {
     | ------------------------- method `is_empty` not found for this struct
...
1082 |         assert!(session.globals.is_empty());
     |                                 ^^^^^^^^ method not found in `GlobalRegistry`
     |
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following traits define an item `is_empty`, perhaps you need to implement one of them:
             candidate #1: `ExactSizeIterator`
             candidate #2: `History`
             candidate #3: `RangeBounds`
             candidate #4: `SampleRange`
             candidate #5: `bitflags::traits::Flags`
             candidate #6: `gimli::read::reader::Reader`
             candidate #7: `nix::NixPath`
             candidate #8: `radix_trie::trie_common::TrieCommon`
             candidate #9: `rand::distr::uniform::SampleRange`
             candidate #10: `rand::seq::slice::IndexedRandom`
             candidate #11: `similar::DiffableStr`
             candidate #12: `toml_edit::table::TableLike`
help: some of the expressions' fields have a method of the same name
     |
1082 |         assert!(session.globals.def_sources.is_empty());
     |                                 ++++++++++++
1082 |         assert!(session.globals.def_to_name.is_empty());
     |                                 ++++++++++++
1082 |         assert!(session.globals.functions.is_empty());
     |                                 ++++++++++
1082 |         assert!(session.globals.imports.is_empty());
     |                                 ++++++++
       and 3 other candidates

error[E0599]: no method named `load` found for type `u32` in the current scope
    --> src/wasm/shared_session.rs:1085:43
     |
1085 |         assert_eq!(session.memory_counter.load(Ordering::Relaxed), 0);
     |                                           ^^^^
     |
help: there is a method `lo` with a similar name, but with different arguments
    --> /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libm-0.2.15/src/math/support/int_traits.rs:272:5
     |
272  |     fn lo(self) -> Self::H;
     |     ^^^^^^^^^^^^^^^^^^^^^^^

error[E0609]: no field `success` on type `std::result::Result<shared_session::ExecuteResponse, std::string::String>`
    --> src/wasm/shared_session.rs:1094:26
     |
1094 |         assert!(response.success);
     |                          ^^^^^^^ unknown field
     |
help: one of the expressions' fields has a field of the same name
     |
1094 |         assert!(response.unwrap().success);
     |                          +++++++++

error[E0609]: no field `value` on type `std::result::Result<shared_session::ExecuteResponse, std::string::String>`
    --> src/wasm/shared_session.rs:1095:27
     |
1095 |         assert!(!response.value.is_empty());
     |                           ^^^^^ unknown field
     |
help: one of the expressions' fields has a field of the same name
     |
1095 |         assert!(!response.unwrap().value.is_empty());
     |                           +++++++++

error[E0609]: no field `success` on type `std::result::Result<shared_session::ExecuteResponse, std::string::String>`
    --> src/wasm/shared_session.rs:1099:27
     |
1099 |         assert!(response2.success || response2.error.is_some());
     |                           ^^^^^^^ unknown field
     |
help: one of the expressions' fields has a field of the same name
     |
1099 |         assert!(response2.unwrap().success || response2.error.is_some());
     |                           +++++++++

error[E0609]: no field `error` on type `std::result::Result<shared_session::ExecuteResponse, std::string::String>`
    --> src/wasm/shared_session.rs:1099:48
     |
1099 |         assert!(response2.success || response2.error.is_some());
     |                                                ^^^^^ unknown field
     |
help: one of the expressions' fields has a field of the same name
     |
1099 |         assert!(response2.success || response2.unwrap().error.is_some());
     |                                                +++++++++

error[E0599]: no method named `clear` found for struct `shared_session::SharedSession` in the current scope
    --> src/wasm/shared_session.rs:1111:17
     |
330  | pub struct SharedSession {
     | ------------------------ method `clear` not found for this struct
...
1111 |         session.clear();
     |                 ^^^^^ method not found in `shared_session::SharedSession`
     |
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following traits define an item `clear`, perhaps you need to implement one of them:
             candidate #1: `BitSetLike`
             candidate #2: `Colorize`
             candidate #3: `History`
             candidate #4: `bitflags::traits::Flags`
             candidate #5: `sharded_slab::Clear`
             candidate #6: `toml_edit::table::TableLike`
             candidate #7: `toml_parser::decoder::StringBuilder`
help: some of the expressions' fields have a method of the same name
     |
1111 |         session.cell_cache.clear();
     |                 +++++++++++
1111 |         session.checkpoints.clear();
     |                 ++++++++++++
1111 |         session.def_graph.clear();
     |                 ++++++++++
1111 |         session.globals.values.clear();
     |                 +++++++++++++++
       and 1 other candidate

error[E0599]: no method named `is_empty` found for struct `GlobalRegistry` in the current scope
    --> src/wasm/shared_session.rs:1113:33
     |
131  | pub struct GlobalRegistry {
     | ------------------------- method `is_empty` not found for this struct
...
1113 |         assert!(session.globals.is_empty());
     |                                 ^^^^^^^^ method not found in `GlobalRegistry`
     |
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following traits define an item `is_empty`, perhaps you need to implement one of them:
             candidate #1: `ExactSizeIterator`
             candidate #2: `History`
             candidate #3: `RangeBounds`
             candidate #4: `SampleRange`
             candidate #5: `bitflags::traits::Flags`
             candidate #6: `gimli::read::reader::Reader`
             candidate #7: `nix::NixPath`
             candidate #8: `radix_trie::trie_common::TrieCommon`
             candidate #9: `rand::distr::uniform::SampleRange`
             candidate #10: `rand::seq::slice::IndexedRandom`
             candidate #11: `similar::DiffableStr`
             candidate #12: `toml_edit::table::TableLike`
help: some of the expressions' fields have a method of the same name
     |
1113 |         assert!(session.globals.def_sources.is_empty());
     |                                 ++++++++++++
1113 |         assert!(session.globals.def_to_name.is_empty());
     |                                 ++++++++++++
1113 |         assert!(session.globals.functions.is_empty());
     |                                 ++++++++++
1113 |         assert!(session.globals.imports.is_empty());
     |                                 ++++++++
       and 3 other candidates

error[E0599]: no method named `export` found for struct `shared_session::SharedSession` in the current scope
    --> src/wasm/shared_session.rs:1139:35
     |
330  | pub struct SharedSession {
     | ------------------------ method `export` not found for this struct
...
1139 |         let export_data = session.export();
     |                                   ^^^^^^ method not found in `shared_session::SharedSession`

error[E0599]: no method named `import` found for struct `shared_session::SharedSession` in the current scope
    --> src/wasm/shared_session.rs:1159:30
     |
330  | pub struct SharedSession {
     | ------------------------ method `import` not found for this struct
...
1159 |         let result = session.import(import_data);
     |                              ^^^^^^ method not found in `shared_session::SharedSession`

error[E0599]: no method named `load` found for type `u32` in the current scope
    --> src/wasm/shared_session.rs:1161:43
     |
1161 |         assert_eq!(session.memory_counter.load(Ordering::Relaxed), 50);
     |                                           ^^^^
     |
help: there is a method `lo` with a similar name, but with different arguments
    --> /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libm-0.2.15/src/math/support/int_traits.rs:272:5
     |
272  |     fn lo(self) -> Self::H;
     |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `super`
    --> src/wasm/notebook.rs:4036:9
     |
4036 |     use super::*;
     |         ^^^^^

warning: unused import: `super`
   --> src/transpiler/provenance.rs:383:9
    |
383 |     use super::*;
    |         ^^^^^

warning: unused import: `super`
   --> src/testing/snapshot.rs:601:9
    |
601 |     use super::*;
    |         ^^^^^

warning: unused import: `super`
    --> src/runtime/assessment.rs:1136:9
     |
1136 |     use super::*;
     |         ^^^^^

warning: unused variable: `cmd`
   --> src/backend/compiler.rs:298:13
    |
298 |         let cmd = build_rustc_command(rust_file, &options);
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_cmd`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `i`
   --> src/backend/compiler.rs:540:13
    |
540 |         for i in 0..5 {
    |             ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `parser`
    --> src/frontend/parser/utils.rs:1139:17
     |
1139 |         let mut parser = Parser::new("()");
     |                 ^^^^^^ help: if this is intentional, prefix it with an underscore: `_parser`

warning: variable does not need to be mutable
    --> src/frontend/parser/utils.rs:1139:13
     |
1139 |         let mut parser = Parser::new("()");
     |             ----^^^^^^
     |             |
     |             help: remove this `mut`
     |
     = note: `#[warn(unused_mut)]` on by default

warning: unused variable: `i`
   --> src/notebook/testing/property.rs:207:14
    |
207 |         for (i, cell) in notebook.cells.iter().enumerate() {
    |              ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `cell2`
   --> src/notebook/testing/property.rs:290:13
    |
290 |         let cell2 = Cell {
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_cell2`

warning: variable `any_different` is assigned to, but never used
   --> src/notebook/testing/property.rs:402:17
    |
402 |         let mut any_different = false;
    |                 ^^^^^^^^^^^^^
    |
    = note: consider using `_any_different` instead

warning: value assigned to `any_different` is never read
   --> src/notebook/testing/property.rs:405:17
    |
405 |                 any_different = true;
    |                 ^^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?
    = note: `#[warn(unused_assignments)]` on by default

warning: unused variable: `content`
   --> src/notebook/testing/migration.rs:564:13
    |
564 |         let content = "def test_foo(): assert True";
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_content`

warning: unused variable: `expected_pattern`
    --> src/quality/linter.rs:1919:21
     |
1919 |         for (input, expected_pattern) in test_cases {
     |                     ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_expected_pattern`

warning: unused variable: `linter`
    --> src/quality/linter.rs:1941:13
     |
1941 |         let linter = Linter::new();
     |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_linter`

warning: unused variable: `linter`
    --> src/quality/linter.rs:2077:13
     |
2077 |         let linter = Linter::new();
     |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_linter`

warning: unused variable: `float_val`
   --> src/runtime/actor.rs:677:13
    |
677 |         let float_val = MessageValue::Float(3.14);
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_float_val`

warning: unused variable: `bool_val`
   --> src/runtime/actor.rs:678:13
    |
678 |         let bool_val = MessageValue::Bool(true);
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bool_val`

warning: unused variable: `stop`
   --> src/runtime/actor.rs:805:13
    |
805 |         let stop = SupervisorDirective::Stop;
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_stop`

warning: unused variable: `escalate`
   --> src/runtime/actor.rs:806:13
    |
806 |         let escalate = SupervisorDirective::Escalate;
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_escalate`

warning: unused variable: `resume`
   --> src/runtime/actor.rs:807:13
    |
807 |         let resume = SupervisorDirective::Resume;
    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_resume`

warning: variable does not need to be mutable
   --> src/runtime/observatory.rs:578:13
    |
578 |         let mut observatory = create_test_observatory();
    |             ----^^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
    --> src/runtime/observatory.rs:1034:13
     |
1034 |         let mut observatory = create_test_observatory();
     |             ----^^^^^^^^^^^
     |             |
     |             help: remove this `mut`

error[E0382]: borrow of partially moved value: `success`
   --> src/runtime/replay.rs:558:42
    |
539 |             EvalResult::Success { value } => assert_eq!(value, "42"),
    |                                   ----- value partially moved here
...
558 |         let json = serde_json::to_string(&success).unwrap();
    |                                          ^^^^^^^^ value borrowed here after partial move
    |
    = note: partial move occurs because value has type `std::string::String`, which does not implement the `Copy` trait
help: borrow this binding in the pattern to avoid moving the value
    |
539 |             EvalResult::Success { ref value } => assert_eq!(value, "42"),
    |                                   +++

warning: unused variable: `input_id1`
   --> src/runtime/replay.rs:629:13
    |
629 |         let input_id1 = recorder.record_input("let x = 42".to_string(), InputMode::Interactive);
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_input_id1`

warning: unused variable: `input_id2`
   --> src/runtime/replay.rs:637:13
    |
637 |         let input_id2 = recorder.record_input("x * 2".to_string(), InputMode::Interactive);
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_input_id2`

warning: unused variable: `ops`
   --> src/testing/generators.rs:255:13
    |
255 |         let ops = vec![
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_ops`

warning: unused variable: `ops`
   --> src/testing/generators.rs:286:13
    |
286 |         let ops = vec![
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_ops`

warning: unused variable: `id`
    --> src/wasm/notebook.rs:3793:13
     |
3793 |         let id = runtime.add_cell("code", "print('test')");
     |             ^^ help: if this is intentional, prefix it with an underscore: `_id`

Some errors have detailed explanations: E0027, E0061, E0063, E0223, E0277, E0308, E0369, E0382, E0433...
For more information about an error, try `rustc --explain E0027`.
warning: `ruchy` (lib test) generated 39 warnings
error: could not compile `ruchy` (lib test) due to 164 previous errors; 39 warnings emitted
error: process didn't exit successfully: `/home/noah/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/cargo test --manifest-path /home/noah/src/ruchy/Cargo.toml --target-dir /home/noah/src/ruchy/target/llvm-cov-target --lib` (exit status: 101)
make: *** [Makefile:247: coverage] Error 1
