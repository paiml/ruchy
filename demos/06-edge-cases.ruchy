# Demo 6: Edge Cases and Error Conditions
# Stress test the language with boundary conditions, errors, complex expressions

# Numeric edge cases
let max_int = 9223372036854775807
let min_int = -9223372036854775808
max_int
min_int

# Float precision
let small = 0.000000000001
let large = 1e12
small
large
small + large

# String edge cases
let empty = ""
let unicode = "ðŸš€ Hello ä¸–ç•Œ! ðŸŒŸ"
let multiline = "Line 1\nLine 2\nLine 3"
empty
unicode
multiline

# Array edge cases
let empty_array = []
let nested = [[1, 2], [3, [4, 5]], []]
let mixed_types = [1, "hello", [2, 3], { x: 4 }]
empty_array
nested
mixed_types

# Deep nesting test
let deep = { a: { b: { c: { d: { e: "deep value" } } } } }
deep.a.b.c.d.e

# Complex expressions
let complex = (1 + 2) * (3 + 4) / (5 - 3) + (6 * 7) % 8
complex

# Pattern matching edge cases
let test_patterns = |value| => {
    match value {
        null => "null value",
        [] => "empty array",
        [x] if x > 100 => "big single element",
        [x, y] if x == y => "equal pair",
        { x: val } if val > 10 => "object with big x",
        _ => "other"
    }
}

test_patterns(null)
test_patterns([])
test_patterns([150])
test_patterns([5, 5])
test_patterns({ x: 20, y: 30 })
test_patterns("random")

# Recursion stress test
fn fibonacci(n) {
    if n <= 1 {
        n
    } else {
        fibonacci(n - 1) + fibonacci(n - 2)
    }
}

# Test with reasonable values to avoid timeout
fibonacci(5)
fibonacci(10)

# Lambda complexity
let complex_lambda = |x| => |y| => |z| => x * y + z
let partial = complex_lambda(2)
let more_partial = partial(3)
more_partial(4)

# Method chaining
let data = [5, 1, 9, 3, 7, 2, 8, 4, 6]
let result = data
    .filter(x => x > 3)
    .sort()
    .map(x => x * 2)
    .slice(0, 3)
    .reverse()
result

# Error recovery testing
# These should be handled gracefully:

# Undefined variable access
try {
    undefined_var
} catch {
    "Undefined variable handled"
}

# Array bounds
try {
    let arr = [1, 2, 3]
    arr[100]
} catch {
    "Array bounds handled"
}

# Type mismatches  
try {
    let str = "hello"
    str + 42  # This should work actually, test string coercion
} catch {
    "Type mismatch handled"
}

# Division by zero
try {
    42 / 0
} catch {
    "Division by zero handled"
}

# Memory stress (reasonable limits)
let large_array = (1..1000).map(x => x * x)
large_array.length()

# Unicode and special characters
let special = "Tab:\t Newline:\n Quote:\" Backslash:\\"
special

# Boolean logic complexity
let complex_bool = (true || false) && !(false || (true && false))
complex_bool

# Null handling
let null_ops = null
null_ops?.missing
null_ops ?? "default"