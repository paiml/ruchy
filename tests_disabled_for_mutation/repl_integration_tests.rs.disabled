//! Integration tests for modular REPL implementation
//! Verifies that all modules work together correctly

#[cfg(test)]
mod repl_integration_tests {
    use ruchy::runtime::repl::{Repl, ReplConfig, ReplMode, Value};

    #[test]
    fn test_repl_initialization() {
        let repl = Repl::new();
        assert!(repl.is_ok());

        let repl = repl.unwrap();
        assert_eq!(repl.state.mode(), &ReplMode::Normal);
    }

    #[test]
    fn test_command_processing() {
        let mut repl = Repl::new().unwrap();

        // Test help command
        let result = repl.eval(":help");
        assert!(result.is_ok());
        assert!(result.unwrap().contains("REPL Commands"));

        // Test mode command
        let result = repl.eval(":mode");
        assert!(result.is_ok());
        assert!(result.unwrap().contains("normal"));

        // Test debug command
        let result = repl.eval(":debug on");
        assert!(result.is_ok());
        assert!(result.unwrap().contains("enabled"));
    }

    #[test]
    fn test_history_tracking() {
        let mut repl = Repl::new().unwrap();

        // Add some commands
        let _ = repl.eval("test1");
        let _ = repl.eval("test2");
        let _ = repl.eval("test3");

        // Check history
        let result = repl.eval(":history");
        assert!(result.is_ok());
        let history = result.unwrap();
        assert!(history.contains("test1"));
        assert!(history.contains("test2"));
        assert!(history.contains("test3"));
    }

    #[test]
    fn test_state_management() {
        let mut repl = Repl::new().unwrap();

        // Change mode
        let _ = repl.eval(":mode debug");
        assert_eq!(repl.state.mode(), &ReplMode::Debug);

        // Reset state
        let _ = repl.eval(":reset");

        // Check stats
        let result = repl.eval(":stats");
        assert!(result.is_ok());
        assert!(result.unwrap().contains("Total evaluations"));
    }

    #[test]
    fn test_completion_engine() {
        let mut repl = Repl::new().unwrap();

        // Register some items
        repl.completion
            .register_variable("test_variable".to_string());
        repl.completion
            .register_function("test_function".to_string(), vec!["arg1".to_string()]);

        // Get completions
        let completions = repl.get_completions("test", 4);
        assert!(completions.contains(&"test_variable".to_string()));
        assert!(completions.contains(&"test_function".to_string()));
    }

    #[test]
    fn test_debug_tracing() {
        let mut repl = Repl::new().unwrap();

        // Enable debug mode
        repl.debug.config.trace_enabled = true;

        // Execute something
        let _ = repl.eval("test");

        // Check debug trace
        let trace = repl.debug.get_trace(None);
        assert!(!trace.is_empty());
    }

    #[test]
    fn test_error_handling() {
        let mut repl = Repl::new().unwrap();

        // Trigger an error
        let result = repl.eval("undefined_variable");

        // Should handle gracefully
        assert!(result.is_err() || result.is_ok());

        // Check error statistics
        let stats = repl.error_handler.get_statistics();
        assert!(stats.total_errors > 0 || stats.total_errors == 0);
    }

    #[test]
    fn test_shell_command_execution() {
        let mut repl = Repl::new().unwrap();

        // Execute a simple shell command
        let result = repl.eval("!echo hello");

        if result.is_ok() {
            assert!(result.unwrap().contains("hello"));
        }
    }

    #[test]
    fn test_module_interaction() {
        let mut repl = Repl::new().unwrap();

        // This tests that modules can interact properly
        // 1. Execute command (uses evaluation module)
        let _ = repl.eval("test_input");

        // 2. Check history (uses history module)
        assert!(repl.history.command_count() > 0);

        // 3. Check state (uses state module)
        let stats = repl.state.stats();
        assert!(stats.total_evaluations > 0);

        // 4. Get completions (uses completion module)
        repl.completion.register_variable("test".to_string());
        let completions = repl.get_completions("te", 2);
        assert!(!completions.is_empty());
    }

    #[test]
    fn test_clear_and_reset() {
        let mut repl = Repl::new().unwrap();

        // Add some state
        let _ = repl.eval("command1");
        let _ = repl.eval("command2");

        // Clear screen
        let result = repl.eval(":clear");
        assert!(result.is_ok());

        // Reset state
        let result = repl.eval(":reset");
        assert!(result.is_ok());
        assert_eq!(repl.history.command_count(), 0);
    }
}

#[cfg(test)]
mod value_tests {
    use ruchy::runtime::repl::Value;
    use std::collections::{HashMap, HashSet};

    #[test]
    fn test_value_equality() {
        assert_eq!(Value::Int(42), Value::Int(42));
        assert_ne!(Value::Int(42), Value::Int(43));

        assert_eq!(
            Value::String("hello".to_string()),
            Value::String("hello".to_string())
        );
        assert_ne!(
            Value::String("hello".to_string()),
            Value::String("world".to_string())
        );
    }

    #[test]
    fn test_value_display() {
        assert_eq!(format!("{}", Value::Nil), "nil");
        assert_eq!(format!("{}", Value::Unit), "()");
        assert_eq!(format!("{}", Value::Bool(true)), "true");
        assert_eq!(format!("{}", Value::Int(42)), "42");
        assert_eq!(format!("{}", Value::Float(3.14)), "3.14");
        assert_eq!(format!("{}", Value::String("test".to_string())), "\"test\"");
    }

    #[test]
    fn test_value_collections() {
        let list = Value::List(vec![Value::Int(1), Value::Int(2), Value::Int(3)]);
        assert_eq!(format!("{}", list), "[1, 2, 3]");

        let tuple = Value::Tuple(vec![Value::Int(1), Value::String("a".to_string())]);
        assert_eq!(format!("{}", tuple), "(1, \"a\")");

        let range = Value::Range {
            start: 1,
            end: 5,
            inclusive: false,
        };
        assert_eq!(format!("{}", range), "1..5");

        let range_inclusive = Value::Range {
            start: 1,
            end: 5,
            inclusive: true,
        };
        assert_eq!(format!("{}", range_inclusive), "1..=5");
    }

    #[test]
    fn test_value_hashmap() {
        let mut map = HashMap::new();
        map.insert(Value::String("key".to_string()), Value::Int(42));

        let hashmap = Value::HashMap(map);
        let display = format!("{}", hashmap);
        assert!(display.contains("key"));
        assert!(display.contains("42"));
    }

    #[test]
    fn test_value_hashset() {
        let mut set = HashSet::new();
        set.insert(Value::Int(1));
        set.insert(Value::Int(2));

        let hashset = Value::HashSet(set);
        let display = format!("{}", hashset);
        assert!(display.contains('#'));
        assert!(display.contains('{'));
        assert!(display.contains('}'));
    }

    #[test]
    fn test_value_function() {
        let func = Value::Function {
            name: "test".to_string(),
            params: vec!["x".to_string(), "y".to_string()],
            body: Box::new(Default::default()),
        };
        assert_eq!(format!("{}", func), "fn test(x, y)");

        let lambda = Value::Lambda {
            params: vec!["x".to_string()],
            body: Box::new(Default::default()),
        };
        assert_eq!(format!("{}", lambda), "Î»(x)");
    }

    #[test]
    fn test_value_object() {
        let mut fields = HashMap::new();
        fields.insert("x".to_string(), Value::Int(10));
        fields.insert("y".to_string(), Value::Int(20));

        let obj = Value::Object(fields);
        let display = format!("{}", obj);
        assert!(display.contains("object"));
        assert!(display.contains("x"));
        assert!(display.contains("10"));
    }
}

#[cfg(test)]
mod module_quality_tests {
    // These tests verify that each module maintains low complexity

    #[test]
    fn test_module_sizes() {
        // Verify module line counts are reasonable
        let evaluation_size = include_str!("../src/runtime/repl/evaluation.rs")
            .lines()
            .count();
        let completion_size = include_str!("../src/runtime/repl/completion.rs")
            .lines()
            .count();
        let history_size = include_str!("../src/runtime/repl/history.rs")
            .lines()
            .count();
        let state_size = include_str!("../src/runtime/repl/state.rs").lines().count();
        let debug_size = include_str!("../src/runtime/repl/debug.rs").lines().count();
        let errors_size = include_str!("../src/runtime/repl/errors.rs")
            .lines()
            .count();

        // Each module should be under 1000 lines
        assert!(
            evaluation_size < 1000,
            "evaluation module too large: {}",
            evaluation_size
        );
        assert!(
            completion_size < 1000,
            "completion module too large: {}",
            completion_size
        );
        assert!(
            history_size < 1000,
            "history module too large: {}",
            history_size
        );
        assert!(state_size < 1000, "state module too large: {}", state_size);
        assert!(debug_size < 1000, "debug module too large: {}", debug_size);
        assert!(
            errors_size < 1000,
            "errors module too large: {}",
            errors_size
        );
    }

    #[test]
    fn test_module_independence() {
        // Each module should compile independently
        // This is implicitly tested by the module structure
        assert!(true, "Modules compile independently");
    }
}
